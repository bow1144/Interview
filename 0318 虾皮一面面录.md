==嗯，ok，那我们就开始今天下午的这一场面试，呃，我们今天呢是这一个虾皮的这样的一个呃暑期的这样的主张的暑期的一个实习面试。然后呃我这边主要是会分三个阶段来对你进行一个简单的一个考核，然后这三个阶段分别是第一阶段的话，我会根据你简历里面提到的一些内容，然后会有一些针对性的这样的一个问答。如果说在我提的问题呢，如果你了解，那你就直接说出答案就好了，如果说你不了解的话，那你就说不了解，那我们就直接进行到下一期。啊。第二个阶段的话就是会有一个小的代码考核题目，然后需要你使用你最擅长的编程语言，把这个代码的实现并且得到最终的结果。第三个阶段的话就是针对你感兴趣的问题，然后我们就做一些这样的一个讨论。==

嗯，好的，我了解了。

==嗯，嗯，好的，那呃在这个面试的这样的一个正式开始之前呢，那就先请你做一个简单的自我介绍吧。==

嗯，好的，那我就开始自我介绍了，呃，我叫张博文，现就读于中南大学的计算机学院，大三。呃，今天参加的是沙皮的后端开发的一面，呃，我非常有幸能够参与今天虾皮的这场面试，在大学的前两年半中，呃，我在学校学习了计算机网络，呃，操作系统、数据结构等计算机的核心基础课程。呃，此外呢我也学习了Java的后端开发等等技术，哎，并且在老师的帮助下我也完成了我自己的项目。呃，总而言之呢，我非常有幸能够参加今天的面试，我对后端开发呢也有比较浓厚的兴趣。我平常呢通过写代码题、撰写技术博客等方式我去实现呃提升自己的技术，我呢也非常希望在下面这个平台通过实习继续提升我自己的技术。

==嗯，好，嗯，好的，呃，快递简历里面提到了一些做过的这样的一些项目，那这个项目的话是你自己呃个人研究的呢还是说在一些在公司里面做的呢？==

呃，那我就先来说一下我的第一个项目吧，我第一个项目并不是我自己一个人独立完成的，呃，这个项目是从去年12月开始我和另外两个同学一起完成的。呃，呃，我负责的主要是后端的部分，一位，另一位同学负责是前端的部分，还有一位同学负责的是将这个项目上平上线以及这个项目的压力测试等等。所以说我主要完成的是它的后端部分，呃，包括数据库和Java开发。
*此时应该甩锅：一位同学负责前端，另一位同学负责测试和一小部分后端开发*

==嗯，那你们做这个项目的这样的一个目的是什么呢？==

嗯。呃，他的目的很简单，是去年我在进行数学数学建模、数学建模竞赛。这个过程中，呃，我深刻的意识到了呃AI人工智能包括gp这些技术在数据数据分析上面的非常广泛的应用，以及非常非常嗯非常光明的前景。呃，但是呢是市面上没有一款专门用来进行数据分析的AI工具。呃，所以说呢我们就决定使用现有的技术，包括AI的接口等等来实现这么一个能够进行智能数据分析的平台。呃，当然还有啊呃也有一个比较大的原因是今去年12月的v三不是呃发布出来了吗？这就使得我们这些人使用AI，包括使用ap API接口这些成本降到一个非常非常低的水平，这样子呢我们就可以一个较为廉价的方式去开发出这么一个平台。

==嗯，嗯，那你们这个平台就是说现在是有一个前端页面，对吧？前端页面。然后去用户去呃上传excel或者说其他的这样的格式的数据，然后把这个文本传给后端，后端去解析，并且去调用这样的一个DC相关的接口。然后然后吐出来你们最终想要的结果，并且用图形化的方式来展示出来，对吧？==

嗯，大体是这样的。

==嗯，那你觉得在这个项目里面在里面遇到的最大的挑战是什么呢？==

嗯，好的，嗯，遇到的最大的挑战其实是刚刚非常火的时候它有一个问题，就是它不停的会显示服务器繁忙，嗯，这样就使得我们到后面才能进行一个比较大规模的测试。呃，其次一个比较严重的问题就是这个这个AI它的输出时间是非常非常长的。嗯，我想要他输出我需要的这个结果，我可能会等到等到半分钟或者更久，这样子对于用户来说体验可能不是那么的好。其次还有一个问题就是呃也不能说这个AI的问题应该是绝大部分AI的通病，就是它会出现一个比较严重的幻觉，呃，我比方说我要它输出一个基于前端vivo这么一个编程语言，这样就会比较好的在前端输出它的图形，但是呢嗯它会经常说出一些呃前缀呀，后缀呀，包括一些注释等比较呃比较有幻觉的东西。这样子呢呃对于我们对它的这个代码的处理就会比较复杂，呃，这是我们要解决的主要原因。对于我这位后端开发来说，呃，嗯，我遇到了一个问题，就是呃怎么说呢？就是呃它的q PS可能会比较低，因为呢我们可能就用的云平台它只有两个核心。这样子的话呢后期的压力比较大的话，呃，它一定它短时间能处理的请求处理的数据，他的可能没有办法达到一个能够商用的等级。

==嗯，那刚才提到的这些关于幻觉这样的一个问题，你们是怎么解决的呢？==

嗯，关于幻觉，嗯，一方面呢我们就是通过pro的，通过在用户输入的数据以及我们想要我们想要他输出的内容方面对他进行非常严格的pro的限制，我们会首先会对他进行身份约束，我们会让他成为一个数据分析师包以及前端的工程师。呃，其次呢我们会严格要求他输出xs一xs这种代码，并且严格规约它的版本是v五这种版本。呃，第三呢我们会严格要求他不允许输出除了呃除了代码之外的任何前缀、后缀等。呃，第四呢，您可以看到我简历中写的是将excel转换成CS，但是呢在写完简历之后我们对它进行了改进，我们了解到AI相比于读CS，它其实更喜欢读mac这种格式的数据，呃，mac相对于CS它的输入tokens并没有变得很多，而且呢AI阅读更倾向于我们人类阅读自然文本这么一种情况。呃，也就是说AI对于mac来说接受程度会更高一些。所以说呢我们将excel转化成mac格式发送到我们的AI接口，这样子呢不仅可以减少AI的幻觉，还可以帮助AI去阅读这个数据，呃，从而使得AI点呃进行一个比较合理化的输出。

==嗯，那你们这样的一个excel转到呃转到这样的一个是你们前端的同事做的还是后端后端来处理的呀？==

呃，这个是我处理的。呃，因为呢我们了解到有呃后面有excel这个库，我们先将excel使用excel这个库转化成cs、v，再将cs、v通过字符字符替换变成mac格式。嗯，通过字符替换是指把它替换成表格吗？呃，因为呃因为CS它数据之间隔的不是逗号吗？呃，二中间隔的是这个竖着的符号，我将所有的逗号替换成了竖着的符号。嗯，那竖着的符号那在麦克他在那个渲染之后它是它是什么样的一个形式呢？展示形式。嗯，嗯，嗯，宣染之后就是这样的一个表格的形式。因为因为我们包括我们看到的网页其实都是mark写的嘛，呃，我们看到网页上的表格那些那个符号就是mac的符号，这样子呢传传给AI之后呢，它就可以更好的阅读这个表格。

*Apache POI 可以直接将 xlsx 转化为 md 格式*

==嗯，那还有一点的话就是比较感兴趣的是就是说你们未来解决AI gc生成慢的问题，对吧？使用了线程词加任务对待来实现了AI cc的并发执行，减少了用户72%的等待时间。这个我想了解一下，就是说呃他这对于同一个用户的这样的一个请求来说，对吧？那你是并发的调用呃后面的这样的一个接口吗？==

嗯，对于统一还是怎么处理的这个事情。嗯，好的，那我就说一下用户调用户是如何调用后端的AI吧。呃，我们将用户的这个用户的诉求，包括临时数据打包之后，我们会将它首先会把它放入到线程池来，性能池，如果说线程性能池能够对它进行处理的话，那么这个线程池会作为生产者将这个消息发送到消息队列中。呃，其实我们对于消息队列的使用，我们并没有特别的使用消息队列的异步化这个优点。呃，因为线程线程池就已经可以对我们的消息进行消风旋呃旋风限流了，所以呢使用消息队列来特殊的进行旋风下流并不是特别有有有意义。消息队列在我们这个任务中最主要的作用是应用结构，将后端和AI的呃将后端的操作和AI的操作分离，这样子可以提高我们的扩展性。

==嗯，那你把这样的你的你用线程池接收到呃处理用户的请求，然后丢到消息队列里边，那这个时候用户在做什么事情？是给用户反馈的结果还是用户在等待呀？==

嗯，用户在等待。呃，因为呢AI要处理我们我们认为应该平均的处理的时间在20秒到30秒。呃，我们这个时候只会给用户一个消息来处理的消息，

==嗯，也就是说你处理了用户的这样的第一个请求之后，你会给用户返回这样的一个正在处理中这样的一个状态，是这个意思吗？==

嗯，是的，我们并不是特别支持一个用户在短时间内使用特别多次这个接口，

==嗯，那你给用户返回处理中之后，那你什么时候在他用户是怎么感知到他最终的结果的呢==

好的，这就涉及到消息队列的回调函数了，因为我们知道这是一个异步非阻塞的过程，当AI的线程完成了它的任务之后，a呃AI线程会调用它的回调函数通知线程，通知我们后端的线程这个任务已经完成了，并且将后端的信息将AI处理的信息发送给前端。

==嗯，也就是说你现在是呃呃是这个流程就是说先生词去消呃去接收用户的这样的一个请求，对吧？把用户的请求丢到消消任务队列里面，嗯，然后呢然后同时会给用户返回这样的一个处理症状的一个状态，对吧？嗯，然后在消任务队列这边然后去消费或者说去请求你的这个后端的这样的一个大模型平台，等他有结果之后，你会通过这样的他的一个回调函数，对吧？然后去再把这个信息返回给用户，是这个意思，对吧？==

嗯，嗯，是这样的。

==嗯，那在你在使用线程池的过程当中，对吧？那你是怎么创建的这样的一个线程池呢？==

嗯，呃，我嗯那我就说一下我们对线程池的这个参数的处理吧。呃，呃，首先呢我们这个项目的背景是我们的云平台只有两个CPU核心线程，是第一个比较重要的参数，是核心线程数。呃，嗯，我们学习到呢核心线程数有这么一个经验公式，对于io密集型的这么一个任务，我们一般将核心线程数设计为CPU核心数的两倍，但是呢这个项目它是它的CPU基本上没有任何计算的重量，基本上所有的处理方面都堆积在io处理上面。呃，所以说呢我们也了解到另外一个比较精确的经验公式。这个经验公式呃将现成的核心书与CPU的核心数的比值呃设置为了一个嗯设计呃，设计成了一个呃线程等待时间比较比上线程运行时间的这么一个比值。而通过实际测量我们的线程等待时间和线程运行时间，我们将这个比值设计成了四，也就是说对于两个CPU核心我们设置出了八个线程核心，也就是说线程池的最小线程数。呃，第二个核心参数是呃最大的呃是线程池的最大线程数，这个这个我们按照惯例设置成了呃八个最小线程数的两倍，也就是16个最大线程数。第三个重要的参数是呃工作队列的类型，呃，我们了解到工作队列的类型一共有四种，分别是有界队列，呃，无界队列、优先级队列和同步队列。呃，我们最终使用的是有界队列，因为是这样的，我们的任务目前来讲是没有优先级区分的，如果后面有VIP用户的话，我们会专门开一个消息队列处理VIP用户。呃，而有界队列相比无界队列的好处在于无界队列它可能会积累过多的任务，这样子呢会导致out of memory这个问题的出现。呃，其次呢有阶段裂，即使我们只把有阶段裂的最大的长度设置成了500甚至400，呃，我们的处理的瓶颈也并不在有界队列的这么一个长度上面。呃，所以说呢工作队列我们最后选择长度为500的有界队列。呃，此外呢呃线程呃线程池还有几个不太重要的参数，包括存活时间，呃，存活时间的单位呃以及拒绝策略等等。呃，那我就说一下，我再说一下拒绝策略吧。呃，我所知道的具体策略一共有四种，是aboard，呃，还有discard和disco。呃，我选择我选择的具体策略是aboard，也就是说当线程池无法在接受更多的线程的时候，我们会直接给后端报一个错，并且通过spring boot的全局凑出、全局抛出异常处理给用户返回这么一个服务器繁忙的标志。呃，因为呢我所了解到呃color run另一种方法，也就是color run，它呢呃会让原本的线程去处理这么一个任务，这对于我们的任务来说有点太繁重了，而且也会导致线程变多。而两种discount的方法呢它并不会抛出任何异常，这就会导致我们的客户没有感知的就是损失掉这个任务，也就是说最后我们还是选择抛出异常，并且给前端反反应，反应给客户说我们的服务器繁忙。

==嗯，那刚才我们提到先生词里边它的这么多的这样的一些参数，对吧？其中就有提到就是说他有这样的一个核心线程数和最大线程数，对吧？那他们两个之间是有什么关系呢？或者说什么时候才会使用到这个最大线程数里面的线程呢？==

嗯，好的，那我就来说一下我们的线程进入到性能值值之后的逻辑吧。首先呢，呃我们知道线程池中它是有一个最小存货线程数，也就是我们的核心线程数，当一个线程进入到线程池的时候，如果还有空闲的核心线程，那么它就会使用这个核心线程完成它的任务。如果说核心线程都用完了，呃，没有活，没有空闲的核心线程了，这个任务就会进入到消息队列中去排队使用到这个核心线程。如果说甚至连消息队列都满了的话，呃，任务队列都满了的话，呃，那么线程池就会额外多开出几个线程，也就是在最大线程最大线程数以内多开出几个额外的线程，将任务队列队列头的线程放到这些额外的线程去中间去处理，这些额外的线程也不是一直存在的。我们之前还提到keep life这个参数，当线程池当额外线程的存活时间高于这个keep a life time之后，这些临时的线程就会被销毁，线程池会回到只有核心线程的这么一个状态。

==嗯，嗯，好的，了解，那你们呃在使用任务队列里面的时候，首先你们使用的是的mk，对吧？那呃对于的mk来讲的话，那你们怎么是怎么实现它的这个消费者和生产者的呢？==

嗯，好的，呃，我们知道mq它是基于生产者消费者的模型，在我的这个项目中生产消息生产者也就是后端，后端是呃后端获得的用户想要请求这么一个数据。而消费者呢则是AI那边他将这些数据进行消费，消费的结果是AI处理的结果，也就是一张图表代码。呃，我们通我们将生产者和消费者的连接，呃，通过消息队列和direct交换机的交换机是一个一对一的交换机，它将一个生产者对应到了一个任务队列中。呃，据我了解交换机除了呃除了direct一对一交换机，还有find out，包括交换机，但是呢我们目前只有一个消息队列去处理我们后段的消息。呃，即使说我们后来会有VIP专属队列，呃，来简短VIP用户的等待时间，我们也会将VIP用户通过div的交换机进行一对一的传输，将VIP用户的数据包一对一的发送到我们的VIP的消息队列中。呃，所以说呢我最后选择了一对一这么一个direct的交换机。

==嗯，那对于任务队列里面的消息他是被并发消费的还是说是单向性消费的呀？==

嗯，它是被并发消费的，嗯，它是整个事件并发消费的呢。嗯，首先呢我我们之前提到过我们的呃。当任务从任务被AI线程拿出来之后，也就是任务被呃任务从消息队列被拿到AI之后，呃，它实现了一个异步的操作。AI线程在完成了这么一个完成了对任务的处理之后，呃，让我呃AI系统会通过回调函数去回调到这个后边的任务中，也就是说呃一个任务只对应一个AI的线程，但是呢消息队列可以对应很多个AI的线程，消息队列将任务分发给这些AI线程。

==呃，这是他呃并发的方式，对于一个任务来说他并不会交给多个，他对一个任务它并不会交给多个AI线程，==

它只会交给一个AI线程去处理

==嗯，呃，呃，首先来说的话，这个AI线程是你们实现的吗？==

嗯，这就是通过接口实现的，通过接口实现的。后期呢我们我们可能会启用官网的adc AI，我们转换我们后期会使用腾讯名的AI，因为呃我们现在用的官网的这个接口不太好用。

==就是你呃你调用这样的它的这样的一个接口，呃，是通过他要么给你提供，要么他是你是使用他的那个API接口，对吧？协议去调查他的这样的一个接口，那你调他不管你是写sdk也好，用他sdk也好，还是说去信用卡的结果还好，那这个动作是是你们实现的吗？==

==嗯，是的，对吧？那这个动作是你们实现的，那你们再去实现这个动作的时候，他这个动作可以并发执行吗？这个动作可以迸发出什么？不贪。呃，就是我这个也就是说你假如说哈现在你这个mk里边有堆积了好多消息，对吧？那这些消息在被消费的时候，他是呃创业型的，被消费的呢还是并行的？被消费的呢？并行被消费了。呃，并行被消费的，对吧？那你们是怎么实现这些消息被并行消费的呢？嗯。呃，我们是将消息发送给我们，我们是直接发送给AI的接口了。==

呃，特别细节的我可能不是特别清楚，因为我我这一点，因为我没有我我之我之前去调用接口，或者说其他的模型的接口，我都是直接用GDP接口来调用的。但是至于你说的这一点就是说他的他能直接消费你q的消息吗？嗯，嗯，呃，呃，因为这一部分是有一部分是我同学实现的，所以说呃这一部分我得我得回忆一下。

==嗯，你思考一下，就是说你调用基本的接口，我理解现在基本上的所有的大模型的接口都是遵循的恰到gp的那一套，对吧？嗯，gp那一套他能给你提供一套标准的这样的一个的接口，让你去封装就好了。嗯，他并不会接收这个平台，并不会接收你的mk消息。嗯，平台接受应该是字符串的消息，你的意思就是说他会接受你iq的消息吗？好的，没关系，这个可以可以呃下去再思考一下，对吧？也可以再再看一下你们那个代码是是怎么实现的，有可能是你们多个同学一块儿做的，只实现了你只看了其中一部分，这倒没关系。==

==然后我们再看你下面的一个问题，就是说为防止单个用户占用大量系统资源使用，实现分布式限流，控制用户访问频率。这个我想了解一下，就是呃首先你们做这个事情的目的是防止用户占用大量系统资源，对吧？那呃那你使用这样的一个分布式限流就能防止用户占用大量的信用资源了吗？==

嗯，呃，虽然是一个分布式的限流，但是我们在我们在实现的时候只用了它的单机部分，也就是说我们会防止一个用户呃一个用户是多次的在短时间内调用大量的资源。因为当时因为当时不是这样的，当时是可以一个用户可以呃点多次一个一个用户可以嗯怎么说？一个用户可以在前端呃不停的点击那个呃提交按钮，也就是把很多的消息发给后端，这样子呢，如果这个用户是爬虫或者说一个恶意软件的话，这样子的我们的后端就很容易被打垮。是radisson是一个客户端。我们用到了它限流的这么一个过程，我们了解到radisson的底层是通过令牌桶这么一个数据结构来进行限流的。

==嗯，就是那你们熔断的思路是什么呢？==

呃，是这样的，我们在进行我们对用户传入的文件和这个excel数据进行检测之前，我们会实现一个熔断器。用户呢首先呃我们想我们的用户首先不对我们的后台首先会从熔断器中检测这个用户是否有是否能够在限流的情况下有权限去进入到我们的后端。如果他没有权限的话，我们就会在传输数，也就是我们会在将数据进行安全检查之前就把这个用户的请求给拒绝掉。

==嗯，那为什么你们已经做了这样的一个限流。为什么还有还要去校验用户有没有权限？也就是说还有一些更高一级的用户他能突破那个，这不是下流吗？==

==呃，不是，我们就是通过这个的限流方案去判断这个用户有没有进入的权限。嗯，那你使用它的这样的一个限流方案，我们暂且不说它那个是单机的还是分布式的，对吧？那你使用它这个方案的话，那你是线的所有的用户还是限的单个用户。单个用户，单个用户。那也就是说你给每个用户都设定了一个令牌桶，==

嗯，这个令牌桶是存在我们系统的后端的，它是针对于每一个用户的ID去分配一个性。呃，是分了一个令牌桶的，呃，也确实是对每一个用户都设置成了一个令牌桶。

==嗯，那呃存在后端是指存在里面还是存在这个数据库里面的存在，==

存在我们的里面也就是我们后端的的继承的客户端。

==嗯，那你们大概介绍一下那你们这个呃这个令牌桶，对吧？它是针对每一个针对单个用户的，那你们的这样的一个实现的这样的一个限流的参数是什么吗？==

嗯，好的，那我就来说一下令牌桶的这么一个参数。那令牌桶它统一装的是虚拟令牌，一个是数据通信的权限。我们呢我们将这个令牌桶的令牌流入的速率设置成了每两秒钟流入一个令牌，呃，一个数据包呃通过一个令牌就可以进入到我们后端的处理流程。哦，哦，对，还有另一桶的。还有另外桶的那个最大容量，我们将另外桶的最大容量设置成了十个。嗯，令牌桶的最大容量使用十个，也就是说每个用户它是这个十个它单位是什么呢？它是多久能花十个？呃，令牌流入的时间是每两秒钟流入一个，也就是说它需要20秒就能装满这个令牌桶。

==嗯，也就是说你每个用户就是说呃相当于是两秒一个，你你的意思就是说他的意思是你的意思就是说他两秒一个一个令牌吗？是这个意思吗？==

嗯，是的。呃，其实呢我们认为这个呃除非特别除非木马或者爬虫或者特别恶意的用户去去突破它，一般的用户是不会被这个限流器卡掉的。

==嗯。好的，我了解了，你们是用这样的一个思路去实现他的这样的。一个这样的一个一一一个思路，对吧？那呃对于这个的话，你们后你们现在是后端部署的一个，那对于Redis的话，你了解还有没有了解其他的这样的一个数据结构呢？==

嗯，red的数据结构吗？嗯，呃，我理解到的数据结构一共有五种，是列表。结合字符串，呃，哈希还有有序集合这五种结构，五种性别结构。那那它的这样的一个列表和集合有什么区别呢？嗯，列表和集合就和Java或者c三的一样，集合，它是只允许相同的元素出现一次，而列表可以允许相同的元素出现多次。

==哦，那允许呃只允许项目出现一次，这个是叫集合呢还是叫那个哈希表？==

嗯，哈希表它是以建筑队的形式存储的，哈，希表的建只允许出现一次，但是只可以出现很多次。嗯，集合在瑞丽斯里边它是哪一个关键字？哪一个关键字呀？嗯，是set，其实我用其实我用ad四用的不是特别多，我只是了解这些。

==嗯。好的，那我们接下来看就是说呃为了防止这样的一个数据这样一个丢失，对吧？你们使用了它的这样的一个接受492用户信息，今天是我自己化之后是以这个字表达什么意思啊？==

嗯，也就是说我们呃我们我们就说我们就来说一下我们的持久化方案吧，就是我们知道rabbit mq它不仅可以传递消息，它还可以作为消息队列来保存消息。mq有这么一个性质，它在即使我们的客户端或者服务端当机之后，它也可以将我们的信息保留下来。呃，这个方案我们是用本地队列降级来做的，当我们的当我们的标的mq级或者说我们的服务单档级之后，我们的我们的消息并不会被发送到QQ里面去了，我们会在本地实现一个blocking。q，实现一个阻塞队列。我们现在将当机之后的消息都发送到本地的消息，消息之后中。呃，这个本地的消息注意力会是每隔一段固定的时间去试探mq到底有没有变活，如果q有活了，那么他就按照先进先出的这么一个顺序将消息发再次发送到web的mq中。呃，我们本地设置的哦，没有对，我们本地设置是q它是用来承受消息的，嗯，它也是在它也是保证了登机之后我们的消息不会被丢失的主要一个方案。

==嗯，好的，那你们在这个过程当中我看你们还是有使用数据库，对吧？那你们使用数据库的过程当中你们使用数据库主要是创建了哪些表呀？==

嗯，好的，我们的数据库主要的表一共有两个，一个是用户表，还有一个是消息表。用户表是不？比如说存放的是用户的嗯头像啊、昵称啊、创建时间啊等等这些这些信息。而消息表则是一个ID自增的表，他将用户询问的所有消息按照时间顺序呃依次排列。这些这个一条消息包括呃用户的原始诉求，用户想要的数据就是用户发送到后端的数据，呃，包括用户想要后端生成的图表，包括时间以及AI的回复。但是呢第二个表也就是消息表，它存在这么一个问题。也就是假如我是用户，我会存放一个大几大几十k大几百k的excel，存放到我的这个消息表中就会导致一个问题，就是这个消息表会随着用户提问的增多以及这个excel表格的越来越大，它这个表格也会呃它这个数据库数据库表也会变得越来越大。于是呢我们使用了分库分表的这么一个思路来对这个数据库进行处理。呃，但这个分库分表呢它是这样的，呃，他将我们用户上传的嗯这么一个excel表格转化为了一个数据库的新表，也就是说专门为这么一条数据去开辟一个新的数据库表。这样子的话，我们的主表就只用存放我们新表的ID，我们新表的命名方法是chess。加上这个呃这条消息的ID，这么做的好处是呃一方面可以减少我们的主表的大小，这么可以这么做可以加快主表的查询和操作。呃，二方面是后续可能会有这么一个功能，就是我们的用户可以在自己的上传的excel表中通过SQL语言去查询他想要的数据。好。

==就是你们刚才提刚才提到的这样的一个分红分表的这样的一个措施，能再介绍一下吗？==

嗯，好的，呃，我先介绍一下这么一条数据它存放了什么内容。包括用户的原始诉求，这是一个字符串。呃，一些用户想要的用户的原始数据，用户的原始数据是一个被转化转化之后的字符串。这么一个字符串它存放在主表中，它会有一个问题，也就是就会导致这个表非常的臃肿，因为某些用户他上传的数据会非常大。所以说呢我们我我们要优化这么一个这么一个字段太大的这么一个缺点，我们将用户上传的excel表格专门专门建立一个数据库表，存放这么一个原始数据。这个数据库新建的表的表明是这条记录的ID加上chas，而我们的图表这么一个字段上面只存储新建的数据表明这样子可以呃可以避免数据主表过于臃肿。

==嗯，你这里说的分户分表，分表是把一个表分成两个表，对吧？是这个意思吗？一个表是存存入你的这个主体信息，一个表存你的这个用户发的这个文本信息是这个意思，对吧？==

呃，并不是一个表分成两个表，呃，而是为每一个每一条每一条每一条记录都单开一个数据库表，每一条数据库计每一条消息都单开一个数据库表。

==嗯，那也就是说用户如果说发了十个十条消息你就会创建十个表，是这个意思吗？==

是的。

==那你是一个用户一个表呢？还是说那你们这个思路是从哪里受到启发的呀？这个那假如说我现在用户发了100万条消息，那你们就创建100万张表吗？==

嗯，理论上来讲是这样的，但我们但我们目前的压测还没有测过这么多数据库表，我们暂且认为他不会爆炸掉，因为它的它的磁盘容量其实并没有变大，因为即使如果我要把数据还是放在那个字段里面，呃，它也不会变小很多。我们暂且认为这种这种方案是有效的。

==什么方法？你你的意思就是说你现在用户发一条消息，你创建一张数据，数据你创建一张表，这种方式是是不可行的。==

嗯，对，我们暂时认为我们暂时认为是可行的。

==嗯，那你嗯了解买身后的这样的一个所有的优化都有哪几种措施吗？==

嗯，好的，买车的索引是一个类似目录的这么一个一个东西，可以通过索引快速的定位到某一条记录。嗯，my索引优化一共有这么几种。第一个是聚簇索引，聚簇索引将整个整个要查询的整个要查询的记录全部放在我们必加树的叶子节点上，将b加树的叶子节点放上记录，而不是指针。这样子呢可以在b加树查找之后不用回表，直接在叶子节点上面查找到我们的消息，这样子可以加快b加树的查呃数据库的查找速率。呃，第二个索引优化点也就是嗯联合索引，《联合索引》将一个数据库的多个列作为索引，呃，比方说我们要通过abc这三个列进行联合索引。那么呢我们会先在b加树上查找a这个列，只有a相同的时候我们再查找b，b相同的时候再查找c。

==呃，不过那联合索引等一下，这是你说的他的这样的一个参照过程。对吧？我想了解的是我们如果说想做一个呃数据库查询的优化，我们都有哪些措施？==

哦，就是呃sq语句的优化吗？嗯，它的优化。嗯呃就是呃第一条肯定是尽量的使用索引，如果使用索引的话就要如果使用《联合索引》的话就要用最左匹配原则。呃，第二点就是在遇浪漫查询之后，要使用explain命令去查询这个。去去去了解这个查询到底是卖在哪里，他有没有做他走的是索引还是全表扫描。第三点是尽量减少select呃select o这个操作，因为这个操作会非常的费时间。呃，那么第四就是要优化表的连接，如果说滥用表的连接的话，也会导致我们的索引不仅是索引，也也包括扫描，它会变得非常的慢。

==嗯，刚才你提到就是说可以使用explain来去看它的这样的一个执行计划，那在explain的执行结果里边它哪些表示哪个哪些关键的这样的一个信息表示他使用了。==

所以呢。嗯，呃，在我看来我会我我我使用xp的话，一般会选择这个这个关键的参数，它可以显示我们索引使用的个数和长度，如果说没有使用索引的话，它这里就它这里就不会显示。如果说我们使用的是联合索引，我们就可以通过key这个关键字去了解到我们使用《联合索引》的方式以及索引的长度。

嗯，ok，好，这个问题我们就先呃看到这里，我这边有一个有一个代码题目，你现在能看到吗？呃，第一题吗？我好像看不到。哦，看第二题吧。嗯。嗯，好的，我看到的是全排列。嗯，对，你看一下这个题目，然后还有没有什么问题？嗯，嗯，没有问题。呃，它的输入是sm输入，对吧？嗯，输入你直接就从在写代码里面就好了。那好的，那我就说一下我的思路了吧。呃，不含重复数字的数组反馈，所有可能的全排列。呃，这个所有可能全排列，我第一个想到的方法也就是DFS报收了，那我就来写一下。好吧？6666这样子啊。Time喂，你在干嘛呢？你在干嘛呢。那个。Good。不行了。啊，等你过来。吃饭了没？嗯。嗯，可以换一种思路吧，这15好像不太对。还有你不认识你吗？你别说。在哪里。Yeah。不行。嗯。你。啊。多天时间有限，我们再给三分钟时间，好吧？嗯，好的。啊，啊啊啊什么呀。你看。The。2。是。快。拜拜。我操。哎呀。哎呀。我就想换一个呀。好的，同学，这个时间关系我们就就就不再去过多的纠结这道小题目了，好吧？嗯，那你大概一分钟时间参与一下思路吧，好不好？嗯，好的，我先我说一下我来写这个词吧，呃，我写的就是呃并不呃在DFS，DFS中不直接输出这个呃不直接输出这个的这个排列，而是我们已经知道纳姆斯的长度，我们输出它的这个呃下标的排列组合，然后来输出，通过这个下标的排列组合所谓的排列组合来输出这个num四，把所有排列组合。下标的拍的多，对，比方说这个詹姆斯的呃纳姆斯的长度是三，我们要说说012021012对应的就是结果的123。嗯。呃，呃，也也可以吧，也行吧。也可以。但问题好像做错了，嗯，但是这个里面它其实我看一下，他其实这个里边它是告诉你的不含重复数字，对不对？如果说数字是重复的，你就没办法使用这个下标的，对吧？如果是数字重复的话，对，如果数字重复的话可能会有重复的输出，对，有重复的输出。所以我们这里面最好还是使用你直接把那个把那个数字把里面的元素记下来是一样的嘛。你记你记录你的下标和记录，你这个元素其实没有区别的。嗯，那你记录你的元素的时候其实你还能做一些去除的操作，对吧？有没有使用或者操作？嗯，是的。嗯，ok，思路基本上是对的，就是使用DNS来去做这样的一个回复嘛。你不会。那我这边的问题呢基本上到这就结束了，看你有什么问题需要问我的吗？嗯，好，那我就长话短说啊，就是嗯嗯就是呃我想知道呃我想我未来可能会实习到工作的主要就是主要的技术站吧。嗯，因为我这边主要是呃做这个Java开发的。所以呃如果说呃因为我我我这边来面试的话，可能后续的主要的工作站可能是呃你刚才简历里面提到的Java维护的那一套，加上他的这样的一些现在常用的一些基本证件店。比如说刚才我们提到的mm q，对吧？然后还有以及还有下面提到的没有收到的keeper还有还有可能还有一些其他你没有用过的。比如说用来做配中心的阿波罗呀，对吧？还有一些做这个定制任务的材料交付啊，可能还有一些其他的这样的一个中间件，它大概的那个架构基本上就是这样的。嗯，好的，我了解了，谢谢，那我就没有什么没有什么需要问的了。嗯，好的，如果没有什么问题的话，我们今天面试就到此结束了。嗯，好的，谢谢。嗯，好的，那好，再见。嗯，再见。好吧？