## 在浏览器输入URL之后会发生什么

1. **输入URL并解析**  
   浏览器解析出协议、主机、端口、路径等，构造一个HTTP请求

2. **DNS域名解析**   
   将域名（URL）解析成一个IP地址

3. **建立TCP三次握手**  
   客户端与服务器端进行HTTP请求和响应

4. **浏览器发送HTTP请求到web服务器**

5. **服务器处理HTTP请求并返回HTTP报文**  
   返回响应报文

6. **浏览器渲染页面**

7. **断开连接之TCP四次挥手**  
   客户端与服务器端断开连接  

## DNS

### 1. DNS是什么
将域名转换为IP地址的分布式系统

### 2. DNS若集中设计产生的问题
1. 若单点故障，则网络瘫痪
2. 全世界集中DNS造成延时
3. 维护成本巨大

### 3. 域名的层级关系
域名用`.`分割，越右边的层级越高

### 4. DNS解析过程
1. 询问浏览器缓存、本地缓存
2. 向本地DNS询问，如果没有，**本地DNS解析器**询问**根DNS**
3. 根DNS告诉本地DNS域名在哪个顶级服务器，顶级服务器告诉本地找哪个权威服务器
4. 权威服务器找到IP地址，返回本地解析器
5. 本地DNS解析器将IP返回浏览器，并缓存域名解析结果
6. 浏览器建立连接，获取网页内容

### 5. 递归查询和迭代查询
* 递归查询适用于普通用户和客户端，客户端只发送一个请求
* 迭代查询适用于DNS服务器之间的通信，一个一个向更高级服务器查询

## HTTP特性与简述

### 简述
* web上的通信都是建立在HTTP协议之上
* www构建技术
  * HTML(*HyperText Markup Language*)
  * HTTP(*HyprtText Transfer Protocol*)
  * URL(*Uniform Resource Location*)

### 版本迭代
1. HTTP/1.0
2. HTTP/1.1
3. HTTP/2.0

### 特性
1. 简单，易于理解
2. 灵活，易于扩展
3. 无状态，明文传输，不安全
   * 无状态：服务器不保存HTTP的状态，解决方式*cookie*
   * 明文传输：容易被窃取
   * 不安全：可以用HTTPS的方式解决：引入SSL/TLS层


## HTTP版本迭代

![HTTP版本迭代](image/HTTP版本迭代.png)

![HTTP各版本](image/HTTP各版本.png)

## HTTP缓存
* 对于已经请求过的资源，客户端或服务器会保存在本地。HTTP缓存分为强制缓存和协商缓存
* 协商缓存需要配合强制缓存使用，只有在未能命中强制缓存时才会发起协商缓存

### 强制缓存
浏览器判断目标资源是否有效命中强缓存，如果命中则直接读取，毋须与服务器做任何通讯
* 强缓存分为`Expires`和`Cache-Control`；`Cache-Control`在资源响应头上写需要缓存多久就行了
* 浏览器第一次访问资源时，在服务器在返回头加上`Cache-Control`，设置过期时间大小
* 再次访问资源时，判断资源是否过期
* 服务器再次请求后，更新`Cache-Control`

### 协商缓存
服务器告知客户端是否可以使用缓存

#### Last-Modified协商缓存
每次请求资源时，服务器判断这段时间资源是否更改，以此判断是否返回新资源。因为可以在短时间修改文件而不返回新的文件，故本方法不常用。

#### ETag协商缓存
优先级更高，将比较时间戳的形式改为比较**文件指纹**（文件的哈希）
* 第一次请求资源时，同时返回文件指纹
* 第二次请求时，客户端提取文件指纹，上传到服务端
* 服务端比较指纹，若没有改变则表示使用缓存，改变了则返回改变后的文件

缺点：
* 需要计算指纹，计算力开销大
* 强验证消耗计算力，弱验证降低指纹有效性

![HTTP缓存](image/HTTP缓存.png)

## HTTPS

### HTTPS协议
* HTTPS：*Hyper Text Transfer Protocol Secure* 超文本安全传输协议
* SSL：安全套接字
* TSL：安全传输层协议
* HTTPS = HTTP+SSL/TSL

### HTTPS的特点
#### 1. 特点
* **信息加密**：对称+非对称的混合加密方式
* **校验机制**：摘要算法生成**指纹**校验码，解决数据被篡改的风险
* **身份证书**：将服务端的公钥放入数字证书中，解决服务端被冒充的风险

#### 2. 优点
* 传输过程中密钥加密，安全性更高
* 可认证用户和服务器，确保数据的正确发送

#### 3. 缺点
* **握手阶段延时较高**：会话前还要SSL握手
* **部署成本高**：加密计算占用CPU资源

### HTTPS与HTTP的区别
* HTTP以明文传输，HTTPS在TCP与HTTP网络层之间加入SSL/TLS安全协议，使得报文可以加密传输
* HTTPS在TCP三次握手之后还要进行SSL/TLS握手，才可以进入报文加密传输
* HTTP的端口号是80，HTTPS是443
* HTTPS需要申请数字证书，确保服务器身份可信

### 信息加密
使用混合加密的方式，对传输的数据加密，解决窃听风险

#### 1. 对称加密
加密和解密都使用相同的密钥，算法速度较快，但一旦泄露，可以很容易被解密数据

#### 2. 非对称加密
公钥和私钥互不相同，一个用于加密，一个用于解密。非对称加密还用于*数字签名*

#### 3. 混合加密
通信建立前用非对称加密，通信建立后使用对称加密。原因考虑解密速度

### 校验机制
用摘要算法生成校验码，检验数据的完整性，解决了被篡改的风险  
摘要算法只能保证内容不被修改，用**非对称加密算法**能保证发送者身份

<img width="530" alt="{F40CD92D-5C50-4955-9DF8-4D0A870E6B82}" src="https://github.com/user-attachments/assets/8478e11d-a23f-4164-b347-710ca13d819a">


### 身份证书
* 将服务器公钥放入CA数字证书中，解决服务器被冒充的风险  
* 数字证书负责解决身份验证的环节
* 证书信任链是数字证书验证过程的一部分，确保证书由可信机构签发

### HTTPS是如何建立的
<img width="467" alt="{2C27C4DF-D424-401A-87FB-6220946CB319}" src="https://github.com/user-attachments/assets/3d236a14-beaf-4f61-8e4e-2a033998cd14">

## TCP与UDP的头部格式

### UDP
<img width="362" alt="{9B826464-147D-4210-A378-7B2DB3BA87A0}" src="https://github.com/user-attachments/assets/d9ad06b9-d351-4753-a959-85ff1e0c39ac">

* 端口：UDP应发送给哪个进程
* 包长度：头部与数据长度之和
* 校验和：校验是否出现差错

### TCP
<img width="361" alt="{6C69F95F-E965-4877-806B-4717401306BA}" src="https://github.com/user-attachments/assets/abd1ae2b-3731-46cd-ad6f-1a1e83a9c458">

* 序列号：解决网络包乱序问题
* 确认应答号：解决丢包问题；序列号和确认应答号用于实现可靠数据传输
* 首部长度：TCP头部字节长度
* 窗口大小：告诉本端TCP缓冲区还有多少空间接收，用以控制流量
* **标志字段**
  * ACK：是否成功接收报文段确认
  * RST：重置混乱连接，或拒绝无效连接
  * SYN：请求建立连接
  * FIN：断开连接
* **TCP选项**：可变长度，最长40字节
  * 第一个字段*kind*说明选项类型
  * 第二个字段*length*说明选项总长度
  * 第三个字段*info*是选项具体信息
  
## TCP的三次握手

### 三次握手的过程

<img width="390" alt="{8F054089-2AE5-4A00-9BCC-AA70F41A8545}" src="https://github.com/user-attachments/assets/a277e117-08ec-4da2-85be-8bd4d319fd20">

#### 第一次握手：SYN报文
客户端随机初始化序列号`client_isn`，放入TCP**序列号**，并将SYN设置为1，表示发起连接。之后客户端处于`SYN-SENT`状态

#### 第二次握手：SYN+ACK报文
服务端在收到SYN报文后，将自己的随机初始化序列号`server-isn`放入TCP**序列号**，并在**确认应答号**填入`client_isn+1`，将SYN与ACK置为1，并将SYN+ACK发送给客户端，进入`SYN-RCVD`状态，表示服务器接收客户端请求，希望建立连接

#### 第三次握手：ACK报文
客户端将ACK标志设置为1，在**确认应答号**填入`server-isn+1`，将报文发送给服务端。**这次可以携带数据**，之后客户端处于`ESTABLISHED`状态，表示客户端准备与服务器进行数据传输

### 为什么需要三次握手
> 三次握手才能保证双方具有接收和发送的能力

#### 1. 阻止重复历史连接的初始化（主因）
* 如果客户端连发两个SYN，第二个SYN到达后客户端会判定这是一个**历史连接**，发送RST给服务端，释放连接
* 如果只有两次握手，客户端在收到一个SYN后就会`ESTABLISHED`，向客户端发送数据，造成资源浪费

#### 2. 同步双方初始序列号
TCP协议通信双方都要维护一个**序列号**，序列号是可靠传输的关键
1. 第一个携带客户端初始序列号报文
2. 第二个携带服务器初始序列号报文
3. 第三个携带服务器ACK应答报文
两次握手只能保证客户端序列号被服务器端接收，四次握手浪费了一次

#### 3. 避免资源浪费
如果只有两次握手，服务器每收到一个SYN就会建立一个连接，造成资源浪费

### 什么是半连接队列
* 服务器把**第一次收到的SYN请求连接**放入队列中，称之为半连接队列
* 已经完成三次握手的队列称之为**全连接队列**

### 什么是SYN攻击
攻击者伪造大量SYN，不完成后续握手过程，消耗服务器半连接队列与系统资源，导致服务器端无法与客户端连接

## TCP四次挥手

<img width="390" alt="{CB76378C-1B5B-47AC-803C-9CEC5395E77F}" src="https://github.com/user-attachments/assets/25b39f35-df13-457c-8009-ac59ed9091d0">

### 四次挥手的过程
1. 第一次挥手：客户端打算关闭连接时，发送FIN置1的**FIN报文**。此时客户端不再发送数据，但还可以接收数据
2. 第二次挥手：服务端收到后，发送ACK应答报文，将客户端序列号+1作为ACK的**序列号**，表明接收到客户端的报文
3. 第三次挥手：服务端处理完数据后，向客户端发送FIN报文
4. 第四次挥手：客户端收到FIN报文后应答ACK报文
5. 服务器收到ACK后处于`CLOSE`状态
6. 客户端在`2MSL`后自动进入`CLOSE`状态

### 为什么挥手四次
相比于建立连接的三次握手，断开连接时**服务端FIN与ACK分开发送**。ACK应答客户端，服务端可能还有数据需要处理和发送。不再发送数据时再发送FIN表示同意关闭

### 为什么需要TIME_WAIT状态
1. 网络中可能有滞留数据，这个时间让两个方向上的数据包都被丢弃，保证再出现的数据包都是新连接产生的
2. 保证最后的ACK可以被接收端收到。如果服务器没有收到ACK，服务端会重发FIN。一来一回刚好`2MSL`

### 为什么TIME_WAIT的时间是2MSL
1. MSL是`Maximum Segment Lifetime`报文最大生成时间，是报文在网络上存在的最长时间。超过这个时间报文将被丢弃
2. 发送方的数据包被接收方处理又响应耗时刚好2MSL
3. 一个MSL确保发送方ACK到达服务端，一个MSL确保没有收到重传FIN报文
4. 收到FIN重传，2MSL重新计时
5. TIME_WAIT太大的话浪费内存资源和本地端口

## TCP的机制
![TCP的机制](https://github.com/user-attachments/assets/a89359df-8883-4362-a965-902ec77a7f1a)

## TCP的重传机制
接收端收到信息后会回复消息表示收到消息。如果传输过程中数据包丢失，用重传机制解决问题

### 超时重传
设定一个计时器，超过指定时间没有收到ACK，就会重发数据
* **RTT与RTO**：*RTT*是往返时延，指的是数据包往返时间；*RTO*是超时重传时间，略大于RTT，且动态变化：超时数据再次超时时，`RTO *= 2`

### 快速重传
快速重传机制不以时间驱动，而以数据驱动。收到三个相同的ACK时，会在定时器过期前重传丢失报文

### SACK 选择性确认
解决重传哪些报文的问题；在TCP头部加入`SACK`，将已收到的数据信息发送给发送方，发送方只重传丢失的数据

### D-SACK
告诉发送方有哪些数据重复发送了
1. 让**发送方**知道是发出去的包丢了还是ACK丢了
2. 可以知道是不是**发送方**的数据包被网络延时了
3. 知道网络中是不是把发送方的数据复制了

## TCP的滑动窗口

### 窗口
* 即使往返时间很大，也不会降低通信效率
* 窗口的实现实际上是OS的缓存空间，在确认ACK收到前，消息缓存在缓冲池中
* 累计确认：ACK返回代表之前每个消息都受到了

### 什么决定窗口大小
TCP头部有一个字段*window*，是接收端告诉发送端还有多少缓冲区可以接收数据。**窗口大小由接收方窗口大小决定**

接收窗口大小**约等于**发送窗口大小，因为信息传输时延。

### 发送方的滑动窗口
<img width="553" alt="{2CE3D737-775F-445F-A4FF-5563DDD94A4E}" src="https://github.com/user-attachments/assets/3cf31945-38e8-47f3-bc81-bc8658ec049a">

### 程序如何表示发送方的四个部分
<img width="547" alt="{BFFE1487-B700-4068-8095-663B5BAF6EF8}" src="https://github.com/user-attachments/assets/ced60a30-75e7-43c6-bb0b-a632f0664397">

## TCP的流量控制机制
**基本原理**：滑动窗口机制，接收方可以通过调整窗口大小告诉发送方当前数据处理能力

* **发送速率调整**：发送方通过接收方通告的窗口大小调整发送速率
* **动态调整**：如果网络拥塞或接收方处理速度变慢，流量发送速率减小

## TCP的拥塞控制机制
网络拥塞时，如果发送方继续发送数据包，会导致时延，丢包等。TCP重传数据会导致负担更重，拥塞控制是避免发送方的数据填满网络。拥塞控制通过**拥塞窗口**防止过多数据注入网络。

* 拥塞窗口`cwnd`是发送方维护的状态变量，由网络拥塞程度变化。。拥塞程度越大，`cwnd`减小
* 发送窗口的值是`swnd = min(cwnd, rwnd)`，拥塞窗口与接收窗口的最小值

拥塞控制常见算法：慢启动，拥塞避免，拥塞发生，快速恢复

### 1. 慢启动
* 发送方每收到一个ACK，拥塞窗口`cwnd`大小**翻倍**
* 慢启动有一个门槛`ssthresh`，`cwnd >= ssthresh`时使用_拥塞避免算法_

### 2. 拥塞避免
* 一般`ssthresh`的大小为65536字节，超过后进入拥塞避免
* 每收到一个ACK，`cwnd += 1/cwnd`，变成线性增长

### 3. 拥塞发生

#### （1）超时重传的拥塞发生算法
1. `ssthresh = cwnd/2`
2. `cwnd = 1`
3. 重新开始慢启动。方式激进，容易造成卡顿

#### （2）快速重传的拥塞发生算法
TCP认为这种情况不严重，因为没有全丢  
1. `cwnd /= 2`
2. `ssthresh = cwnd`
3. 进入快速恢复算法

### 4. 快速恢复
1. `cwnd = ssthresh + 3` （有三个数据包被收到了）
2. 重传丢失数据包
3. 若再收到重复ACK，`cwnd ++`
4. 若收到新数据ACK，`cwnd = ssthresh` ,恢复

<img width="600" alt="{快速恢复}" src="https://github.com/user-attachments/assets/8f7a0e96-1083-438f-82e8-5330c9b294db">

## IP网络层基础

### IP基础
![IP基础](https://github.com/user-attachments/assets/e24ea340-aa80-4a9a-8b1d-6f1556a38822)

* 网络层的主要作用：主机与主机之间点对点通信
* 网络层（IP）与数据链路层（MAC）的关系：IP负责没有直连的主机间通信，MAC负责直连设备的通信

## IP地址

<img width="413" alt="{F733A0C2-809C-41CB-9749-7251287BD9A1}" src="https://github.com/user-attachments/assets/099e071c-bc8f-4c44-9c2f-685c935dc6f5">

实际上43亿给IP地址时远远不够用的，但是可以通过**更换IP地址的技术NAT**，使得连接计算机数超过43亿

IP地址被分为ABCDE五类

### （1）A、B、C类地址

<img width="391" alt="{0131086B-99EB-4ECD-8276-C9516849E7EA}" src="https://github.com/user-attachments/assets/e40d7c40-7b07-4091-ac0d-c3a8d8db9202">

* IP地址被分为**分类号、网络号、主机号**。ABC三类各个号的长度不同
* 广播被分为**本地关闭**和**直接广播**。本地广播只分享本链路，直接广播可以分享给其它网络

### （2）D、E类广播

<img width="543" alt="{9C555DA1-BF7C-460E-87AA-EA0C1EA479A3}" src="https://github.com/user-attachments/assets/d6ecde3f-5d9e-4fb1-b2d3-d137251d994c">

<img width="534" alt="{95038242-B8F8-49E8-A2F2-21FA5FCB0955}" src="https://github.com/user-attachments/assets/0a08860b-cade-4c28-a299-33900e71043f">

### （3）IP分类的优缺点

* 优点：可以通过前四位判别IP地址种类，选路简单
* 缺点：
   1. 没有地址层次划分，缺少灵活性
   2. 不能与现实网络世界匹配，一个网络能包含的地址太多或太少
 
### （4）CIDR无分类地址
* 不再有分类地址的概念，32比特位被分为**网络号与主机号**两部分。
* `a.b.c.d/x`表示前x位是网络号，后面的是主机号

#### 4-1：如何划分网络号和主机号

以 `10.100.122.2/24`为例
* **可用地址个数**：254 ( $2^{32-24}-2$ )
* **子网掩码**：      `255.255.255.0` (网络号置1，主机号置0)
* **网络号**：        `10.100.122.0` (主机号置0)
* **第一个可用地址**：`10.100.122.1`
* **最后可用地址**：  `10.100.122.254`
* **广播地址**：      `10.100.122.255`

#### 4-2：为什么要分离网络号和主机号
* 两台计算机通信，先判断是否在一个广播域（网络）中，若在一个网络中则直接发送数据
* 路由寻址选法中，先找到网络号再发到对应主机中

#### 4-3：如何进行子网划分

<img width="323" alt="{25B0DE65-5541-4995-962F-1259A70D742E}" src="https://github.com/user-attachments/assets/2809d70b-ae4a-451a-9b5a-8c39a6f82f5f">

### 公有IP地址与私有IP地址
* ABC类地址可以分为公有地址和私有地址
* 公有地址由权威机构管理，私有地址由内部IT人员管理

### IP地址与路由控制
* **路由表**：存储IP地址与其对应的下一跳
* **环回地址**：`127.0.0.1`，不会流向网络，`localhost`主机名同样不会

### IP分片与重组
* 分片的目的是要契合数据链路的**最大传输单元（MTU）**，IP数据包大于MTU时，IP数据会分片
* 一旦某个分片丢失，整个IP数据包作废

### IPv6的基本认识
#### 1. 亮点
* 地址变多
* 自动配置
* 简化首部结构，减轻路由性能，提高传输性能
* 安全性提高

#### 2. 地址标识方式

<img width="564" alt="{801301E0-E6B8-420D-B62D-8D0EC66D096B}" src="https://github.com/user-attachments/assets/a4cb582d-ef4c-46c5-b51a-ba21d69a8a8e">

#### 3. 地址结构

<img width="390" alt="{C2181F75-A667-48AA-872D-671AA18BF79A}" src="https://github.com/user-attachments/assets/195df831-7ee6-40e3-82bd-51d14d50c95d">

* 相比于IPV4，IPV6新增在子网下新增了**链路**
* 在同一链路单播通信，可以不经过路由器，直接在本地单播地址，这是IPv4所没有的
* 在内网单播，相当于IPv4的私有IP
* 在互联网通信，相对于IPv4的公有IP

### IPv4首部与IPv6首部
<img width="500" alt="{EE486C22-C315-4A4A-AE78-C94E347A456B}" src="https://github.com/user-attachments/assets/06d50e11-60c0-4b9a-99ce-a21d2c95b3db">

<img width="500" alt="{7A09CC37-7DE0-489F-BBB1-A2AA186F18A8}" src="https://github.com/user-attachments/assets/e5c42eb3-a12b-4129-93ad-b2dc335513c1">

<img width="393" alt="{4FC97D20-1B6E-4DD0-A31A-60F238C0A2B9}" src="https://github.com/user-attachments/assets/55482fd7-b25d-4390-8281-5aa256091702">

#### 不同之处
1. **取消首部检验和**：因为在数据链路层与传输层都会检验，故IPv6取消了IP的校验
2. **取消分片/重组相关字段**：IPv6不允许路由器分片重组，这种操作只在源与目标主机。这样提升传输效率
3. **取消选项字段**：选项出现在IP六的*下一个首部*指出的位置上。因此IPv6的首部长度成为**固定的40字节**

## IP协议

### 1. ARP与RARP协议

#### （1）ARP协议
* ARP协议，即 *Address Resolution Protocol 地址解析协议*
* 作用是通过下一跳的**IP地址求得MAC地址**，从网络层到数据链路层
* 原理是ARP请求与ARP响应
  1. 主机广播ARP请求，包中包含了目标IP
  2. 一个链路中所有设备拆包，如果包中目标IP与自己的IP一致，将自己的MAC地址返回给主机
  3. 操作系统会把第一次ARP获取的MAC地址缓存（有期限），便于下次直接找MAC地址
 
#### （2）RARP协议
* 与ARP协议相反，已知MAC地址求IP地址
* 小型嵌入式设备接入网络时使用。设备通过RARP服务器注册MAC与IP地址

### 2. DHCP协议
* DHCP协议，即 *Dynamic Host Configuration Protocol 动态主机配置协议*
* 电脑通过DHCP动态获取IP地址，省去了配置IP信息繁琐的过程

1. 客户端发起**DHCP发现报文**的IP数据报，使用**UDP广播**，目的地址是`255.255.255.255`并使用`0.0.0.0`作为源IP地址。链路将帧广播到所有网络中设备
2. DHCP服务器收到报文后，用**DHCP提供报文**做出响应，仍使用`255.255.255.255`.该报文信息暴扣IP地址，子网掩码，默认网关，DNS服务器以及**IP地址租用期**
3. 客户端收到一个或多个报文后，从中选择一个服务器发送**DHCP请求报文**，回显配置参数
4. 最后，都无端响应，应答要求的参数

* 如何续约IP地址：客户端向服务器发送DHCP请求报文
* 每个网络都要配置一个DHCP服务器？：用DHCP中继代理。收到DHCP广播后用**中继单播**向上发送给服务器

### 3. NAT网络地址转换
* NAT协议，即 *Network Address Translation 网络地址转换*
* 作用是将私有IP地址转换为公有IP，缓解IPv4地址数量少的问题
* 原理：将私有IP网络的数个IP地址压缩为**一个公用IP地址的不同port**

<img width="551" alt="{41505BAF-2F2B-40DA-B427-DA1D8DB4E341}" src="https://github.com/user-attachments/assets/b35d32e5-8d45-4ba5-b51c-4e8312841e93">

* 缺点
   * 外部无法与NAtions内部服务器建立连接
   * 转换表消耗资源
   * 如果NAT重启，所有TCP都要被重置
* NAT穿透：应用程序发现自己位于NAT后，主动获得NAT公有IP，为自己建立端口映射条目

### 4. ICMP互联网控制报文协议
* ICPM *Internet Control Message Protocol*
* 主要功能包括确认IP包是否达到目标地址，IP包废弃原因，改善网络设置

<img width="448" alt="{F8B08EFA-779C-49C1-AD3D-830F1A6390DC}" src="https://github.com/user-attachments/assets/6a03df2c-22bd-453d-bc27-3060c77fad7b">

* ICPM目前分为两类
  1. 用于诊断查询消息的*查询报文类型*
  2. 通知出错原因*差错报文类型*
 
### 5. IGMP因特网组管理协议 
