### 数据库怎么分类，描述以下对数据库的理解？
* 数据库按数据模型分类分为**关系型和非关系型**数据库
  - 关系型数据库：基于关系模型组织的数据库，如MySQL，Oracle
  - 非关系型数据库不用传统表格存储数据，如Redis
* 我的理解是，数据库**用于存储、管理、检索数据的系统**；关系型数据库通过结构化查询语言管理数据，需要保证数据一致性与完整性，NoSQL更加灵活，需要非结构化数据和可伸缩场景

### 什么情况下用MySQL，什么情况下用Redis？
* 结构化数据、复杂查询操作、支持事务处理时用MySQL；快速访问和处理数据缓存时用Redis
* 一般Redis用作MySQL的缓存，访问数据可以直接从内存读取

### 排他锁和共享锁是什么，有什么区别？
* 排他锁是写锁，锁定时不允许其它事务读写；共享锁是读锁，锁定之后也可以被其它事务读取
* 换句话说，排他锁是独占的，一次只能由一个事务持有，二共享锁允许多个事务同时持有资源

### MySQL的行级锁有哪些，有什么作用？
* 包括`Record Lock`记录锁、`Gap Lock`间隙锁、`Next-key Lock`临键锁
* 记录锁包括排他锁和共享锁，仅把一条记录锁上
* 间隙锁锁定一个范围，只存在于**可重复读**、作用是防止幻读
* 临键锁是以上两种的组合，作用是**保护记录、阻止新纪录被插入间隙**

### 数据库的悲观锁、乐观锁的使用场景有哪些？
* 乐观锁认为并发冲突是小概率事件，不用每次都对数据上锁；适用于**读多写少**的程序
* 悲观锁通过锁机制，对数据修改采取保守态度，适用于**写操作多**的程序

### MySQL有哪两种缓存，说下区别？
* MyISAM存储引擎、innoDB存储引擎
* 事务：innoDB支持事务，MyISAM不支持事务
* 索引：InnoDB 是聚簇索引，MyISAM 是非聚簇索引
* 锁粒度：InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁，并发访问受限
* count：InnoDB需要遍历整表，MyISAM用变量存储count

### 执行SELECT语句后发生了什么？
1. **连接器**：与客户端连接，获取权限
2. **查询缓存**：如果命中缓存直接返回结果
3. **解析SQL**：通过解析器对语法、词法解析，构建语法树
4. **执行SQL**
   - 预处理：检查字段是否存在、将`*`扩展为所有的列
   - 优化：选择查询成本最小的执行计划
   - 执行：从存储引擎读取数据，返回客户端
  
### 【重要】事务的四大特性有哪些？
事务的四大特性是ACID

* 原子性：事务的所有操作要么全部成功，要么全部失败回滚
* 一致性：事务执行前后，数据库都是一致性状态（有效状态）
* 隔离性：多个事务并发执行时，每个事务被隔离，一个事务的执行不影响其它事务
* 持久性：一旦事务提交，永久改变，即使系统崩溃也保持

### 【重要】数据库的事务隔离级别有哪些？
数据库的事务隔离级别包括四个：读未提交、读已提交、可重复读、序列化

* 读未提交：最低隔离，允许事务读取另一事务尚未提交的数据修改
* 读已提交：解决**脏读**、只能读取别的事务已提交的数据
* 可重复读：事务之间多次读取数据会得到相同结果，解决了不可重复读的问题
* 序列化：串行执行，解决所有问题

### MySQL两个线程同时update一条语句，会不会阻塞？
会，因为会加写锁

### 滥用事务，或者一个事务有特别多sql的弊端？
* 执行时间长，造成主从延时
* 锁定数据太多，造成死锁和超时
* 回滚时间长

### 两条update语句处理一张表的不同的主键范围的记录，一个<10，一个>15，会不会遇到阻塞？底层是为什么的？
* 不会，因为行级锁的范围不一样

### 如果2个范围不是主键或索引？还会阻塞吗？
* 不用行级锁，用全表扫描，全表加行级锁
* 即使本身可能没有交集，也会因为锁而阻塞

### 除了表锁，行锁这些，还有别的形式的锁吗？
* 全局锁，使整个数据库处于只读状态

### 为什么MySQL索引使用B+Tree？
* 相比于红黑树，B+Tree是多叉树，树高更矮
* 有大量冗余节点，使得B+Tree的插入删除效率更高
* 叶子节点用链表连接，范围查询效率高

### 介绍关系范式？
关系范式是一种规范化设计方法，可以减少冗余提升效率

* 第一范式：每个属性值都是最小单元，保证每列的原子性
* 第二范式：主键外其它列全部依赖于主键
* 第三范式：每列都与主键直接相关

### 可以对数据库表做哪些优化？
1. 合理分表，方便管理数据
2. 建立索引：提高查询性能
3. 避免使用`SELECT *`
4. 使用合适的数据类型

### 了解MongoDB吗，和MySQL有哪些区别？
* MongoDB是一种非关系型、无模式数据库，以类似`json`的形式存储
* 提供高性能的读写能力和压缩特性，适用于大量非/半结构化数据
* 具有良好的横向扩展性，通过分片在多台3机器上分布数据

### 【重要】什么是慢查询？原因是什么？可以怎么优化？
* 数据库查询的时间超过指定（10s）时间
* 原因：
  - 查询语句复杂、插叙数据量大
  - 缺少索引、数据库设计不合理
  - 并发冲突
  - 硬件资源不足
* 解决：
  - 优化语句
  - `explain`：更好选择索引
  - `order by limit`，让排序的表先查
  - 建立索引

### 什么是Redis？有什么特点？
Redis是一种基于内存的数据库，读写速度快，通常用作缓存、消息队列、分布式锁等；提供了五种数据结构和分布式特性，可将数据分布在多个节点上

### Redis为什么快？
* 基于内存操作：减少了IO
* 高效的数据结构，提升读写效率
* 单线程，避免上下文切换开销
* IO多路复用，处理器与Socket一一对应

### 为什么Redis是单线程？
Redis的瓶颈不在CPU而在内存和带宽，而单线程容易实现，自然使用单线程

### 为什么Redis又要引入多线程呢？
后来发现内存也不是瓶颈，瓶颈在于网络IO，故用多线程处理网络IO

### Redis有哪些数据类型？分别有哪些应用场景？
* `String`：缓存对象，计数器，分布式锁
* `List`：消息队列
* `Hash`：缓存对象、购物车
* `Set`：聚合计算
* `Zset`：排行榜等

### Redis底层使用了什么数据结构？
1. 简单动态字符串、双端链表、压缩列表
2. 哈希表、整数集合
3. 跳表：取代红黑树，查找复杂度为 $O(log N)$
4. `quicklist`：链表，每个链表是一个压缩列表

### Redis和MySQL的区别有哪些？
* Redis基于键值对，MySQL是关系型数据库
* Redis在内存工作，MySQL在磁盘工作
* Redis目标是读多写少的应用场景，MySQL适合复杂查询，大规模数据集
* Redis不使用SQL命令集

### Redis为什么不用红黑树而用跳表？
1. 实现简单，容易理解和调试
2. 更好的支持范围查询
3. 在有序集合下插入和删除更加简单

### Redis实现分布式锁
获取锁：使用 Redis 的 `SET` 命令，设置一个唯一的锁键，并指定键的过期时间。通过使用 `NX` 保证只有第一个客户端可以设置锁，防止锁被覆盖。

### 【重要】Redis的持久化机制有哪些？
Redis读写在内存所以效率高，Redis重启恢复数据需要持久化  
* AOF日志：每执行一条写命令，就追加写入到文件中
* RDB快照：将某一时刻的内存数据写入磁盘中
* 混合持久化理论：集成二者的优点

### AOF三种写回策略有哪些？
`always`：每次都写；`everysec`：放入缓冲区，每隔一秒写；`no`：不控制写入时机，写入缓冲区，OS决定何时写入

### 什么是Redis事务？
事务是**一组命令的有序执行序列**，不被其它客户端命令打断；类似于原子性，要么全部执行要么全部回滚

### 缓存的热点数据和冷数据是什么？
热点数据是访问次数较多的数据，冷数据是很少访问的数据；只有热点数据才有缓存的意义

### Redis集群模式有哪些
Redis集群模式包括主从复制、哨兵、切片集群

### Redis的哨兵是干什么的？
* 监控：监控主从服务器
* 故障转移：主服务器有问题时选举新的主服务器，并通知其它服务器

### 主从模式的同步过程是什么？
* 连接协商：从服务器提出同步要求、主服务器响应并包括**主服务器`runiID`和复制进度**
* 主从数据同步：主服务器生成快照，发送给从服务器
* 主服务器开启增量同步：TCP连接，从服务器执行所有主服务器的写命令

### 【重要】哨兵的工作原理是什么？
* 监控：每隔一段时间ping一次从服务器，判断从服务器是否活跃。哨兵认为服务器下线后选举主节点
* 选举：
  1. 选择候选服务器：选择复制偏移量最大的服务器
  2. 计算投票：哨兵为每个候选服务器投票：依据是复制偏移量、连接质量、优先级
  3. 达成共识：哨兵们达成共识、这需要多数哨兵的同意
* 通知客户端：哨兵向客户端发送通知，告知新主服务器的位置，方便连接

### 【重要】缓存雪崩、击穿、穿透和解决方法？
* **缓存雪崩**：某时间点**大量缓存失效**，系统涌入后端；解决方法是合理设置缓存过期时间，分散缓存失效时间点
* **缓存击穿**：**某个缓存失效**，大量请求访问数据库；解决方法是互斥锁保证只有一个请求访问数据库、预热缓存，预先加载热点数据到缓存
* **缓存穿透**：数据在缓存、数据库中都不存在，导致数据库负载巨大

### 【重要】如何保证数据库与缓存的一致性？
* Cache Aside：更新数据时先把数据持久化到数据库、再让缓存失效
* Read/Write Through：由缓存更新数据库：写命中缓存后更新缓存，缓存自己更新数据库
* Write Behind：更新数据时只更新缓存，缓存定时异步更新数据库

### Redis过期删除策略有哪些？
* 定时删除：时间到达后自动删除
* 惰性删除：每次访问key时都检测其是否过期
* 定期删除：每隔一段时间随机选择一些key，删除其中过期的

Redis使用*惰性删除+定期删除*

### 应用中如何使用Redis？
* 缓存层
* 用作消息队列
* 存储会话数据、计数器
