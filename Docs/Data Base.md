# 数据库系统原理

![数据库系统原理](https://github.com/user-attachments/assets/b9f68f58-fbd5-4f9f-972b-9f5cea468bd3)

## 一、事务

### 1.1 概念
事务是指**满足ACID特性**的一组操作，可以通过`Commit`提交一个事务，也可以用`Rollback`进行回滚

### 1.2 ACID

#### 原子性 *Atomicity*
事务被视为最小单元，事务的操作**要么全部成功，要么全部失败回滚**

#### 一致性 *Consistency*
所有事务对同一个数据的读取都是**相同**的

#### 隔离性 *Isolation*
一个事务所做修改再最终提交前，**对其它事务不可见**

#### 持久性 *Durability*
一旦事务提交、修改永久保存。系统崩溃后可以用重做日志*RedoLog*恢复，从而实现持久性

* 只有满足**一致性**，事务的执行结果才是正确的
* 无并发时，**隔离性**一定满足
* 并发环境下，只有满足**隔离性**，才能满足**执行性**
* 事务的**持久化**是为了应对系统崩溃

### 1.3 AutoCommit
`MySQL`默认自动提交，每次查询操作都会被当作事务自动提交

## 二、并发一致性问题
在**并发**环境下很难保证**隔离性**，因此会出现很多并发一致性问题

### 2.1 丢失修改
两个事务同时修改一个数据，导致先修改的事务丢失

![丢失修改](https://camo.githubusercontent.com/932bac678caed46d5d08fe3d46af8c3afeda6ea6a91075934cee33d273c53f29/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67)

### 2.2 读脏数据
读到了别的事务未提交的数据  

![读脏数据](https://camo.githubusercontent.com/4dc95b01443482fa734719e75f9e35e500efadf076796ec3917a90b41a8a416a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67)


### 2.3 不可重复读
由于其它事务，一个事务的两次读取数据不一致  

![不可重复读](https://camo.githubusercontent.com/47ced8ac842829fc04c1b4e348193a6ba98dce079c213533b488f0adb40beebb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67)

### 2.4 幻影读
在一个事务的两次读`size`之间，被别的事务插入导致两次读大小不一致

![幻影读](https://camo.githubusercontent.com/26471f83d42c3ecb43e51f1e53c3d9e4d5da6a76a4802d5be3784b4d2f2d0d57/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323133343330362e706e67)

## 三、封锁
封锁(*Locking*)是一种防止并发一致性的锁

### 3.1 封锁粒度
* `MySQL`提供了两种封锁粒度：**行为锁和表级锁**
* 锁定的范围越小，系统的并发程度越高
* 锁的操作会消耗资源
* 在选择封锁粒度的时候，需要在**锁开销并发程度之间**取舍

### 3.2 封锁类型
#### 1） 读写锁
* 读锁，又称S锁，是共享锁
* 写锁，又称X锁，是互斥锁
* 加了X锁后，其它事务不能再加锁
* 加了S锁后可以再加S锁，但不能加X锁

#### 2） 意向锁
* 基础的读写锁中，事务想对表加锁则需要遍历表的每一行，消耗资源；而意向锁需要对行加锁的同时对**整个表加意向锁**。
* 一个事务要对数据行加锁，必须先获得表的IS/IX锁
* IX锁只表示意向，是兼容的

### 3.3 封锁协议
* **一级封锁协议**：事务修改数据时加X锁，可以解决**丢失修改**的问题
* **二级封锁协议**：在一级的基础上，读取数据加S锁，**读取完了才释放**，解决**读脏数据**的问题
* **三级封锁协议**：在二级的基础上，读取数据**直到结束才释放S锁**，解决**不可重复读**的问题
* **两段锁协议**：加锁和解锁分两个阶段执行，是保证**可串行化**的必要条件

### 3.4 MySQL隐式与显式锁定
采用两段锁协议，根据隔离级别，在需要的时候自动加锁，并且所有锁同时释放。这被称之为隐式锁定

## 隔离级别
**封锁**是**隔离**的手段

### 4.1 未提交读
事务中的修改，即使没有提交，对其它事务也是可见的

###  4.2 提交读
事务的修改只有被提交的才能被其它事务可见

### 4.3 可重复读
保证同一事务中多次读取同一数据的结果一致

### 4.4 可串行化
强制事务串行执行，不会引起并发一致性问题

![隔离](https://camo.githubusercontent.com/f38f1ad145c06f9d16524a31f4fbd00b8af93d100941b3d205a9d5a61aff1078/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232333430303738372e706e67)

## 五、多版本并发控制 MVCC
MVCC通过对每个事务提供**不同版本**的数据，以实现事务之间的隔离与并发访问，避免了传统锁机制带来的性能瓶颈

### 5.1 主要原理
* **版本管理**：每次数据修改都生成一个新的版本，而不是直接覆盖；这些数据版本会有时间戳标识
* **快照隔离**：事务看到的是数据快照（数据的某一版本），避免了脏读和不可重复读
* **事务ID与时间戳**：每个事务有唯一事务ID，通过时间戳判断数据版本可见性

### 5.2 优缺点
* 优点
  - 高并发：MVCC允许事务访问不同版本的数据，避免了锁竞争
  - 避免阻塞：事务不会因为竞争锁而阻塞
  - 减少死锁：MVCC不需要锁，故MVCC可以避免锁竞争引起的死锁问题
* 缺点：
  - 存储开销：要存储多个数据版本，增加了系统的存储开销
  - 版本管理：数据库需要维护管理和清理版本，增加了系统的复杂性
  - 不能解决**幻影读**的问题
 
## 六、Next-Key Locks
Next-Key Locks 与 MVCC组合可以解决幻影读问题  

### 6.1 Record Locks 和 Gap Locks
* Record Locks 会锁定记录的索引而非记录本身
* Gap Locks会锁定索引之间的间隙，但不包含索引本身

### 6.2 Next-Key Locks
是Record Locks 和 Gap Locks 的结合，不仅锁定索引，还锁定索引之间的间隙

### 优缺点
* 优点：防止幻影读，提高隔离性
* 缺点：增大性能开销，有死锁记录，降低并行性

## 七、关系数据库设计理论

### 7.1 函数依赖
* `A->B`表示A函数决定B，也可以说B依赖于A
* A的真子集C有`C->B`，则称B部分依赖于A，否则是完全依赖
* `A->B, B->C` 则 `A->C`
* 若`{A1, A2, A3 ... An}`决定了关系的其它属性，那么这个集合被称为**键码**

### 7.2 异常
* 冗余数据，用范式解决
* 修改异常：修改了一个记录中的信息，另一个记录中的相同信息却没有被修改
* 删除异常：删除一个信息导致其它信息丢失
* 插入异常：无法插入信息

### 7.3 范式
* 1NF：属性不可分
* 2NF：每个非主属性**完全函数依赖于键码**
* 3NF：非主属性**不传递函数依赖于键码**

## 八、ER图
ER图的三个组成部分：**实体、属性、联系**，用来进行关系型数据库的概念设计

# MySQL

![MySQL](https://github.com/user-attachments/assets/e7ef41ff-7d0b-4ebe-a52d-638ae0214548)

## 一、索引

### 1.1 B+Tree

#### 1） 数据结构
`B+Tree`是一种多叉树，相对于平衡查找树，`B+Tree`的节点多了一个**向后指针**，可以指向比它大的同层节点

![image](https://github.com/user-attachments/assets/107e282e-75f1-4f72-b0e7-c386ad0ac0d2)

#### 2） 操作
与搜索树类似的查找，通过分裂，合并，旋转等操作维护平衡性

#### 3） 与红黑树的比较
相比于红黑树，B+树访问磁盘数据又更高的性能
* 更低的树高：是多叉平衡树，树高比红黑树小很多
* 磁盘访问原理：更低的树高意味着磁盘旋转时间更少
* 磁盘预读特性：磁盘预读速度非常快，相邻节点可以被预先载入

### 1.2 MySQL索引
MySQL的索引实在存储引擎层实现的，所以不同的存储引擎有不同的索引类型

#### 1） B+Tree索引
* 是大多数MySQL存储引擎的默认索引类型
* 是有序的搜索树，不用全表扫描只用搜索，查找速度快
* 还可以用于排序与分组
* 适用于全键值、键值范围和键前缀查找
* **主索引**：聚簇索引，按主键顺序存储在磁盘中
* **辅助索引**：索引本身存储主键的值
