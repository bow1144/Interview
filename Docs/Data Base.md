# 数据库系统原理

![数据库系统原理](https://github.com/user-attachments/assets/b9f68f58-fbd5-4f9f-972b-9f5cea468bd3)

## 一、事务

### 1.1 概念
事务是指**满足ACID特性**的一组操作，可以通过`Commit`提交一个事务，也可以用`Rollback`进行回滚

### 1.2 ACID

#### 原子性 *Atomicity*
事务被视为最小单元，事务的操作**要么全部成功，要么全部失败回滚**

#### 一致性 *Consistency*
所有事务对同一个数据的读取都是**相同**的

#### 隔离性 *Isolation*
一个事务所做修改再最终提交前，**对其它事务不可见**

#### 持久性 *Durability*
一旦事务提交、修改永久保存。系统崩溃后可以用重做日志*RedoLog*恢复，从而实现持久性

* 只有满足**一致性**，事务的执行结果才是正确的
* 无并发时，**隔离性**一定满足
* 并发环境下，只有满足**隔离性**，才能满足**执行性**
* 事务的**持久化**是为了应对系统崩溃

### 1.3 AutoCommit
`MySQL`默认自动提交，每次查询操作都会被当作事务自动提交

## 二、并发一致性问题
在**并发**环境下很难保证**隔离性**，因此会出现很多并发一致性问题

### 2.1 丢失修改
两个事务同时修改一个数据，导致先修改的事务丢失

![丢失修改](https://camo.githubusercontent.com/932bac678caed46d5d08fe3d46af8c3afeda6ea6a91075934cee33d273c53f29/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67)

### 2.2 读脏数据
读到了别的事务未提交的数据  

![读脏数据](https://camo.githubusercontent.com/4dc95b01443482fa734719e75f9e35e500efadf076796ec3917a90b41a8a416a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67)


### 2.3 不可重复读
由于其它事务，一个事务的两次读取数据不一致  

![不可重复读](https://camo.githubusercontent.com/47ced8ac842829fc04c1b4e348193a6ba98dce079c213533b488f0adb40beebb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67)

### 2.4 幻影读
在一个事务的两次读`size`之间，被别的事务插入导致两次读大小不一致

![幻影读](https://camo.githubusercontent.com/26471f83d42c3ecb43e51f1e53c3d9e4d5da6a76a4802d5be3784b4d2f2d0d57/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323133343330362e706e67)

## 三、封锁
封锁(*Locking*)是一种防止并发一致性的锁

### 3.1 封锁粒度
* `MySQL`提供了两种封锁粒度：**行为锁和表级锁**
* 锁定的范围越小，系统的并发程度越高
* 锁的操作会消耗资源
* 在选择封锁粒度的时候，需要在**锁开销并发程度之间**取舍

### 3.2 封锁类型
#### 1） 读写锁
* 读锁，又称S锁，是共享锁
* 写锁，又称X锁，是互斥锁
* 加了X锁后，其它事务不能再加锁
* 加了S锁后可以再加S锁，但不能加X锁

#### 2） 意向锁
* 基础的读写锁中，事务想对表加锁则需要遍历表的每一行，消耗资源；而意向锁需要对行加锁的同时对**整个表加意向锁**。
* 一个事务要对数据行加锁，必须先获得表的IS/IX锁
* IX锁只表示意向，是兼容的

### 3.3 封锁协议
* **一级封锁协议**：事务修改数据时加X锁，可以解决**丢失修改**的问题
* **二级封锁协议**：在一级的基础上，读取数据加S锁，**读取完了才释放**，解决**读脏数据**的问题
* **三级封锁协议**：在二级的基础上，读取数据**直到结束才释放S锁**，解决**不可重复读**的问题
* **两段锁协议**：加锁和解锁分两个阶段执行，是保证**可串行化**的必要条件

### 3.4 MySQL隐式与显式锁定
采用两段锁协议，根据隔离级别，在需要的时候自动加锁，并且所有锁同时释放。这被称之为隐式锁定

## 隔离级别
**封锁**是**隔离**的手段

### 4.1 未提交读
事务中的修改，即使没有提交，对其它事务也是可见的

###  4.2 提交读
事务的修改只有被提交的才能被其它事务可见

### 4.3 可重复读
保证同一事务中多次读取同一数据的结果一致

### 4.4 可串行化
强制事务串行执行，不会引起并发一致性问题

![隔离](https://camo.githubusercontent.com/f38f1ad145c06f9d16524a31f4fbd00b8af93d100941b3d205a9d5a61aff1078/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232333430303738372e706e67)

## 五、多版本并发控制 MVCC
MVCC通过对每个事务提供**不同版本**的数据，以实现事务之间的隔离与并发访问，避免了传统锁机制带来的性能瓶颈

### 5.1 主要原理
* **版本管理**：每次数据修改都生成一个新的版本，而不是直接覆盖；这些数据版本会有时间戳标识
* **快照隔离**：事务看到的是数据快照（数据的某一版本），避免了脏读和不可重复读
* **事务ID与时间戳**：每个事务有唯一事务ID，通过时间戳判断数据版本可见性

### 5.2 优缺点
* 优点
  - 高并发：MVCC允许事务访问不同版本的数据，避免了锁竞争
  - 避免阻塞：事务不会因为竞争锁而阻塞
  - 减少死锁：MVCC不需要锁，故MVCC可以避免锁竞争引起的死锁问题
* 缺点：
  - 存储开销：要存储多个数据版本，增加了系统的存储开销
  - 版本管理：数据库需要维护管理和清理版本，增加了系统的复杂性
  - 不能解决**幻影读**的问题
 
## 六、Next-Key Locks
