# 数据库系统原理

![数据库系统原理](https://github.com/user-attachments/assets/b9f68f58-fbd5-4f9f-972b-9f5cea468bd3)

## 一、事务

### 1.1 概念
事务是指**满足ACID特性**的一组操作，可以通过`Commit`提交一个事务，也可以用`Rollback`进行回滚

### 1.2 ACID

#### 原子性 *Atomicity*
事务被视为最小单元，事务的操作**要么全部成功，要么全部失败回滚**

#### 一致性 *Consistency*
所有事务对同一个数据的读取都是**相同**的

#### 隔离性 *Isolation*
一个事务所做修改再最终提交前，**对其它事务不可见**

#### 持久性 *Durability*
一旦事务提交、修改永久保存。系统崩溃后可以用重做日志*RedoLog*恢复，从而实现持久性

* 只有满足**一致性**，事务的执行结果才是正确的
* 无并发时，**隔离性**一定满足
* 并发环境下，只有满足**隔离性**，才能满足**执行性**
* 事务的**持久化**是为了应对系统崩溃

### 1.3 AutoCommit
`MySQL`默认自动提交，每次查询操作都会被当作事务自动提交

## 二、并发一致性问题
在**并发**环境下很难保证**隔离性**，因此会出现很多并发一致性问题

### 2.1 丢失修改
两个事务同时修改一个数据，导致先修改的事务丢失

![丢失修改](https://camo.githubusercontent.com/932bac678caed46d5d08fe3d46af8c3afeda6ea6a91075934cee33d273c53f29/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67)

### 2.2 读脏数据
读到了别的事务未提交的数据  

![读脏数据](https://camo.githubusercontent.com/4dc95b01443482fa734719e75f9e35e500efadf076796ec3917a90b41a8a416a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67)


### 2.3 不可重复读
由于其它事务，一个事务的两次读取数据不一致  

![不可重复读](https://camo.githubusercontent.com/47ced8ac842829fc04c1b4e348193a6ba98dce079c213533b488f0adb40beebb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67)

### 2.4 幻影读
在一个事务的两次读`size`之间，被别的事务插入导致两次读大小不一致

![幻影读](https://camo.githubusercontent.com/26471f83d42c3ecb43e51f1e53c3d9e4d5da6a76a4802d5be3784b4d2f2d0d57/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323133343330362e706e67)

## 三、封锁
封锁(*Locking*)是一种防止并发一致性的锁

### 3.1 封锁粒度
* `MySQL`提供了两种封锁粒度：**行为锁和表级锁**
* 锁定的范围越小，系统的并发程度越高
* 锁的操作会消耗资源
* 在选择封锁粒度的时候，需要在**锁开销并发程度之间**取舍

### 3.2 封锁类型
#### 1） 读写锁
* 读锁，又称S锁，是共享锁
* 写锁，又称X锁，是互斥锁
* 加了X锁后，其它事务不能再加锁
* 加了S锁后可以再加S锁，但不能加X锁

#### 2） 意向锁
* 基础的读写锁中，事务想对表加锁则需要遍历表的每一行，消耗资源；而意向锁需要对行加锁的同时对**整个表加意向锁**。
* 一个事务要对数据行加锁，必须先获得表的IS/IX锁
* IX锁只表示意向，是兼容的

### 3.3 封锁协议
* **一级封锁协议**：事务修改数据时加X锁，可以解决**丢失修改**的问题
* **二级封锁协议**：在一级的基础上，读取数据加S锁，**读取完了才释放**，解决**读脏数据**的问题
* **三级封锁协议**：在二级的基础上，读取数据**直到结束才释放S锁**，解决**不可重复读**的问题
* **两段锁协议**：加锁和解锁分两个阶段执行，是保证**可串行化**的必要条件

### 3.4 MySQL隐式与显式锁定
采用两段锁协议，根据隔离级别，在需要的时候自动加锁，并且所有锁同时释放。这被称之为隐式锁定
