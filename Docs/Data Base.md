# 数据库系统原理

![数据库系统原理](https://github.com/user-attachments/assets/b9f68f58-fbd5-4f9f-972b-9f5cea468bd3)

## 一、事务

### 1.1 概念
事务是指**满足ACID特性**的一组操作，可以通过`Commit`提交一个事务，也可以用`Rollback`进行回滚

### 1.2 ACID

#### 原子性 *Atomicity*
事务被视为最小单元，事务的操作**要么全部成功，要么全部失败回滚**

#### 一致性 *Consistency*
所有事务对同一个数据的读取都是**相同**的

#### 隔离性 *Isolation*
一个事务所做修改再最终提交前，**对其它事务不可见**

#### 持久性 *Durability*
一旦事务提交、修改永久保存。系统崩溃后可以用重做日志*RedoLog*恢复，从而实现持久性

* 只有满足**一致性**，事务的执行结果才是正确的
* 无并发时，**隔离性**一定满足
* 并发环境下，只有满足**隔离性**，才能满足**执行性**
* 事务的**持久化**是为了应对系统崩溃

### 1.3 AutoCommit
`MySQL`默认自动提交，每次查询操作都会被当作事务自动提交

## 二、并发一致性问题
在**并发**环境下很难保证**隔离性**，因此会出现很多并发一致性问题

### 2.1 丢失修改
两个事务同时修改一个数据，导致先修改的事务丢失

![丢失修改](https://camo.githubusercontent.com/932bac678caed46d5d08fe3d46af8c3afeda6ea6a91075934cee33d273c53f29/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67)

### 2.2 读脏数据
读到了别的事务未提交的数据  

![读脏数据](https://camo.githubusercontent.com/4dc95b01443482fa734719e75f9e35e500efadf076796ec3917a90b41a8a416a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67)


### 2.3 不可重复读
由于其它事务，一个事务的两次读取数据不一致  

![不可重复读](https://camo.githubusercontent.com/47ced8ac842829fc04c1b4e348193a6ba98dce079c213533b488f0adb40beebb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67)

### 2.4 幻影读
在一个事务的两次读`size`之间，被别的事务插入导致两次读大小不一致

![幻影读](https://camo.githubusercontent.com/26471f83d42c3ecb43e51f1e53c3d9e4d5da6a76a4802d5be3784b4d2f2d0d57/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323133343330362e706e67)

## 三、封锁
封锁(*Locking*)是一种防止并发一致性的锁

### 3.1 封锁粒度
* `MySQL`提供了两种封锁粒度：**行为锁和表级锁**
* 锁定的范围越小，系统的并发程度越高
* 锁的操作会消耗资源
* 在选择封锁粒度的时候，需要在**锁开销并发程度之间**取舍

### 3.2 封锁类型
#### 1） 读写锁
* 读锁，又称S锁，是共享锁
* 写锁，又称X锁，是互斥锁
* 加了X锁后，其它事务不能再加锁
* 加了S锁后可以再加S锁，但不能加X锁

#### 2） 意向锁
* 基础的读写锁中，事务想对表加锁则需要遍历表的每一行，消耗资源；而意向锁需要对行加锁的同时对**整个表加意向锁**。
* 一个事务要对数据行加锁，必须先获得表的IS/IX锁
* IX锁只表示意向，是兼容的

### 3.3 封锁协议
* **一级封锁协议**：事务修改数据时加X锁，可以解决**丢失修改**的问题
* **二级封锁协议**：在一级的基础上，读取数据加S锁，**读取完了才释放**，解决**读脏数据**的问题
* **三级封锁协议**：在二级的基础上，读取数据**直到结束才释放S锁**，解决**不可重复读**的问题
* **两段锁协议**：加锁和解锁分两个阶段执行，是保证**可串行化**的必要条件

### 3.4 MySQL隐式与显式锁定
采用两段锁协议，根据隔离级别，在需要的时候自动加锁，并且所有锁同时释放。这被称之为隐式锁定

## 隔离级别
**封锁**是**隔离**的手段

### 4.1 未提交读
事务中的修改，即使没有提交，对其它事务也是可见的

###  4.2 提交读
事务的修改只有被提交的才能被其它事务可见

### 4.3 可重复读
保证同一事务中多次读取同一数据的结果一致

### 4.4 可串行化
强制事务串行执行，不会引起并发一致性问题

![隔离](https://camo.githubusercontent.com/f38f1ad145c06f9d16524a31f4fbd00b8af93d100941b3d205a9d5a61aff1078/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232333430303738372e706e67)

## 五、多版本并发控制 MVCC
MVCC通过对每个事务提供**不同版本**的数据，以实现事务之间的隔离与并发访问，避免了传统锁机制带来的性能瓶颈

### 5.1 主要原理
* **版本管理**：每次数据修改都生成一个新的版本，而不是直接覆盖；这些数据版本会有时间戳标识
* **快照隔离**：事务看到的是数据快照（数据的某一版本），避免了脏读和不可重复读
* **事务ID与时间戳**：每个事务有唯一事务ID，通过时间戳判断数据版本可见性

### 5.2 优缺点
* 优点
  - 高并发：MVCC允许事务访问不同版本的数据，避免了锁竞争
  - 避免阻塞：事务不会因为竞争锁而阻塞
  - 减少死锁：MVCC不需要锁，故MVCC可以避免锁竞争引起的死锁问题
* 缺点：
  - 存储开销：要存储多个数据版本，增加了系统的存储开销
  - 版本管理：数据库需要维护管理和清理版本，增加了系统的复杂性
  - 不能解决**幻影读**的问题
 
## 六、Next-Key Locks
Next-Key Locks 与 MVCC组合可以解决幻影读问题  

### 6.1 Record Locks 和 Gap Locks
* Record Locks 会锁定记录的索引而非记录本身
* Gap Locks会锁定索引之间的间隙，但不包含索引本身

### 6.2 Next-Key Locks
是Record Locks 和 Gap Locks 的结合，不仅锁定索引，还锁定索引之间的间隙

### 优缺点
* 优点：防止幻影读，提高隔离性
* 缺点：增大性能开销，有死锁记录，降低并行性

## 七、关系数据库设计理论

### 7.1 函数依赖
* `A->B`表示A函数决定B，也可以说B依赖于A
* A的真子集C有`C->B`，则称B部分依赖于A，否则是完全依赖
* `A->B, B->C` 则 `A->C`
* 若`{A1, A2, A3 ... An}`决定了关系的其它属性，那么这个集合被称为**键码**

### 7.2 异常
* 冗余数据，用范式解决
* 修改异常：修改了一个记录中的信息，另一个记录中的相同信息却没有被修改
* 删除异常：删除一个信息导致其它信息丢失
* 插入异常：无法插入信息

### 7.3 范式
* 1NF：属性不可分
* 2NF：每个非主属性**完全函数依赖于键码**
* 3NF：非主属性**不传递函数依赖于键码**

## 八、ER图
ER图的三个组成部分：**实体、属性、联系**，用来进行关系型数据库的概念设计

# MySQL

![MySQL](https://github.com/user-attachments/assets/e7ef41ff-7d0b-4ebe-a52d-638ae0214548)

## 一、索引

### 1.1 B+Tree

#### 1） 数据结构
`B+Tree`是一种多叉树，相对于平衡查找树，`B+Tree`的节点多了一个**向后指针**，可以指向比它大的同层节点

![image](https://github.com/user-attachments/assets/107e282e-75f1-4f72-b0e7-c386ad0ac0d2)

#### 2） 操作
与搜索树类似的查找，通过分裂，合并，旋转等操作维护平衡性

#### 3） 与红黑树的比较
相比于红黑树，B+树访问磁盘数据又更高的性能
* 更低的树高：是多叉平衡树，树高比红黑树小很多
* 磁盘访问原理：更低的树高意味着磁盘旋转时间更少
* 磁盘预读特性：磁盘预读速度非常快，相邻节点可以被预先载入

### 1.2 MySQL索引
MySQL的索引实在存储引擎层实现的，所以不同的存储引擎有不同的索引类型

#### 1） B+Tree索引
* 是大多数MySQL存储引擎的默认索引类型
* 是有序的搜索树，不用全表扫描只用搜索，查找速度快
* 还可以用于排序与分组
* 适用于全键值、键值范围和键前缀查找
* **主索引**：聚簇索引，按主键顺序存储在磁盘中
* **辅助索引**：索引本身存储主键的值

#### 2） 哈希索引
* 失去了有序性，但查找的时间优化为了`O(1)`
* 无法用于排序、分组；不支持范围查找

#### 3） 全文索引
查找文本中的关键字，而不是直接比较相等

#### 4） 空间数据索引
用GIS相关数据维护空间数据索引

### 1.3 索引优化

#### 1） 独立的列
查询时，索引列**不能是表达式、函数的一部分**，不然会无法使用索引

#### 2） 多列索引
相比于使用多个单列索引，用多列符合的索引可以提高效率

#### 3） 索引列的顺序
把选择性最强的索引放在前面，类似决策树的算法

#### 4） 前缀索引
对`BLOB, TEXT, VARCHAR`类型的列，只索引开始的部分字符

#### 5） 覆盖索引
索引包含了查询所需的所有列，可以通过索引直接获取查询结果

### 1.4 索引的优点
* 减少了服务器需要扫描的行数
* 使服务器避免排序和分组，一面创建临时表
* 将随机IO变为顺序IO

### 1.5 索引的使用条件
* 对于非常小型的表，建立索引不如全表扫描
* 对于中大型的表，索引非常有效
* 对于特大型的表，索引的代价变大；此时需要一种技术可以直接区分出许哟啊查询的数据，而不是一天天的匹配

## 二、查询性能优化

### 2.1 使用Explain进行分析
使用Explain分析`SELECT`语句，优化查询语句

### 2.2 优化数据访问
1. 减少请求的数据量
   - **只返回必要的行列**：最好不适用`SELECT*`，使用`LIMIT`语句限制行数
   - **缓存重复查询的数据**：数据被重复查询时，缓存可以显著提升效率
2. 减少服务器扫描行数
使用索引来覆盖查询

### 2.3 重构查询方式
* 切分大查询：大查询会耗尽系统资源，切分为小查询
* 分解大连接查询：将大连接查询分解为每个表一次单表查询

## 三、存储引擎

### InnoDB
* 是MySQl的默认引擎
* 实现了四个标准的隔离级别，默认级别是可重复读，同时通过MVCC+Next-Key Locking 防止幻影读
* 聚簇索引，对查询性能有很大提升

### MyISAM
* 设计简单，适用于小表、只读数据
* 不支持事务，不支持行级锁

### 比较
* InnoDB是事务型
* MyISAM只支持表级锁，InnoDB还支持行级锁

## 四、数据类型

### 4.1 整型
`Tinyint`,`Smallint`,`mediumint`,`int`,`bigint`分别支持8~64位存储空间

### 4.2 浮点数
`float`和`double`两种浮点数类型

### 4.3 字符串
`Char`,`Varchar`两种定长，变长字符串

### 4.4 时间与日期
* `Datetime`保存**年月日-时分秒**，精度为秒，空间为8字节
* `Timestamp`四个字节，UDC时间，应尽量使用`Timestamp`，因为空间效率更高

## 五、切分

### 5.1 水平切分（*sharding*）
![水平切分](https://camo.githubusercontent.com/b7c18926888b1076e2f0cf372c83bb44a2837309f97bd7f8699d6f052840108d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36336332393039662d306335662d343936662d396665352d6565393137366233316162612e6a7067)

### 5.2 垂直切分
![垂直切分](https://camo.githubusercontent.com/9fec59cd7513e5995a3a6c099457e72af9719614d37c88e4c048d2da1199eb2e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65313330653562382d623139612d346631652d623836302d3232333034303532356366362e6a7067)

### Sharding 策略
* 哈希取模
* 范围
* 映射表

### Sharding存在的问题
* 事务问题
* 连接问题：将原连接分解为多个单表查询
* ID唯一性：全局ID、分布式ID生成器

## 六、复制

### 6.1 主从复制
主从复制是指将数据库的主节点（Master）上的数据同步到一个或多个从节点（Slave）。在这种模式下，主节点负责所有的写操作和数据更新，而从节点则用于读取操作，通常是只读操作

### 6.2 读写分离
* 主服务器负责写操作以及高要求读操作，从服务器负责读操作
* 读写分离能提高性能的原因：
  - 各自负责读写，缓解了锁的竞争
  - 从服务器可以使用MyISAM，解决系统开销
  - 增加冗余，提升可用性

# Redis

## 一、概述
* Redis是速度非常快的非关系型（*NoSQL*）内存键值数据库，可以存储*key*与五种数据之间的映射
* *key*只能为字符串，*value*支持：字符串、列表、集合、散列表、有序集合
* Redis支持将内存数据持久化到硬盘、通过复制扩展读性能、通过分片扩展写性能

## 二、数据类型

|数据类型|可以存储的值|操作|
|---|---|---|
|String|字符串、整数、浮点数|字符串操作、整数浮点数的自增自减|
|List|列表|两端push/pop，对单个/多个元素修剪|
|Set|无序集合|增删查改，计算交并补集，随机读取元素|
|Hash|无序散列表|增删查改键值对|
|Zset|有序集合|增删查改、依据范围获取元素、计算键的排名|

## 三、数据结构

### 字典
* `dictht`是一个散列表结构，用拉链法解决哈希冲突
* Redis的字典`dict`包括两个哈希表`dictht`，方便进行`rehash`操作（扩容）
* 采用渐进式`rehash`，防止服务器负担过大

### 跳跃表

![跳跃表](https://camo.githubusercontent.com/4fdd83d646121a2f9e187b189a03f9c9761d4dd63982d0e896a3b23fa07c57e5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30656133376565322d633232342d346337392d623839352d6531333163363830356334302e706e67)

* 是有序集合的底层实现
* 相比于红黑树的优点：
  - 插入速度非常快（因为不用旋转）
  - 更容易实现
  - 支持无锁操作（在并发环境下操作）
 
## 四、使用场景

