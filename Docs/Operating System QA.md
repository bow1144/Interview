### 进程和线程的区别有哪些？
* 进程是OS资源分配和调度的最小单位，而线程是OS进行运算调度的最小单位
* 线程是进程内的执行单元、线程共享进程的资源
* 在**资源开销**方面，线程创建与销毁、切换的开销远远小于进程
* 在**通信同步**方面，进程之间需要用到消息队列、管道、共享内存等机制，比较麻烦；而线程由于共享资源，所以开销较小
* 在**安全性**方面，进程间隔离，相互影响不大；而线程的错误可能会影响整个进程错误
* **包含关系**：没有线程的进程可看作单线程，否则是多线程

### 多线程比起单线程的优略势？
* 优势在于提高效率，充分利用资源
* 劣势在于加大锁开销，增大死锁风险，消耗系统资源

### 进程状态有哪些？
首先是三种基本状态：就绪、阻塞、运行  
* 就绪：资源完备，一旦得到处理器就可以运行
* 阻塞：缺少资源，在等待事件发生
* 运行：处理器正在处理进程 

还有创建和终止状态：
* 创建：OS分配PCB创建进程的过程
* 终止：进程结束或出现错误

### 进程之间的通信方式有哪些？
主要的通信方式有**共享内存、管道、消息队列、信号量**

* 共享内存：最快的方式，通过读写一块共享内存传递信息
* 管道：半双工且只能在父子进程之间使用
* 消息队列：内核中一块专门用于进程间接通信的区域，进程将消息发送到消息队列中
* 信号量：一种锁机制的计数器，作为同步手段

### 线程同步的方式有哪些？
线程同步的方式主要依靠锁

* 互斥锁：只允许一个线程进入临界区
* 读写锁：允许多个线程读，但只允许一个线程写
* 信号量：控制多个进程访问资源的计数器
* 条件变量：判断线程是否阻塞

### 介绍你知道的锁
两种基础的锁：互斥锁，只允许一个线程访问资源；自旋锁，不断询问资源直到锁被释放。其余的锁都是基于这两种基础锁  
* 读写锁：允许多个线程读，但只允许一个线程写
* 悲观锁：认为资源会遇到多个线程，访问资源时上锁
* 乐观锁：认为资源不会冲突，不上锁

### 什么情况下会死锁？
死锁是**多个进程争夺资源是，都在等待资源释放而无法继续的状态**；死锁只有同时满足**四个必要条件**才能产生：  
1. 互斥条件：资源只能被有限个进程占用
2. 保持请求：进程被阻塞后，不会释放资源
3. 不可剥夺：资源不能被强制剥夺
4. 环路等待：多个进程-资源形成了一个有向环

### 如何解除死锁？
破坏四个条件之一就可以  
* 破坏保持请求：进程需一次性申请所有资源
* 破坏不可剥夺：进程被阻塞后释放所有资源
* 破坏循环等待：按序申请资源，逆序释放资源

### 进程的调度算法有哪些？
**批处理系统**：  
1. 先来先服务
2. 最短作业优先
3. 最短剩余事件优先：抢占式的最短作业，解决了饥饿问题

**交互式系统**
1. 时间片轮转：按FIFS排队，但时间片结束还没执行完 就回到队尾
2. 优先级调度：按优先级排队，为防止饥饿对等待时间长的进程提高优先级
3. 最短进程优先
4. 多级队列：上面的队列**时间片处理短优先级高**，目的是减少轮转次数

### 分页和分段的区别
* 分段按照逻辑段区分，大小动态变化，分页按固定大小分
* 二者都会产生内部碎片，而分页解决了外部碎片
* 分段的逻辑地址由段号和段内偏移组成，分页的由页号和页内偏移组成

### 页面置换算法有哪些？
页面置换算法主要有五种：最近最少使用LRU、FIFO、最佳页面置换OPT、时钟页面置换算法、最不常用算法

* 最近最少使用LRU：维护一个页面列表：使用一个页面就放在表底，表满后置换第一个
* FIFO：先进先出
* OPT：置换未来最少用的页面，属于复杂的理想算法
* 时钟置换算法：当发⽣缺⻚中断时，顺时针遍历⻚⾯，如果访问位为1，将其改为0，继续遍历，直到访问到访问位为0⻚⾯，进⾏置换
* 最不常用算法：记录页面访问次数

### 介绍IO多路复用？
IO多路复用允许单个进程处理多个IO，可以避免阻塞和浪费
1. 工作原理：
   * 注册多个文件描述符以及监听事件
   * 等待IO事件
   * 事件通知：IO事件准备好时，OS通知进程
   * 处理事件
2. 常见IO复用机制
   * `select`：最古老的机制，性能较差
   * `poll`：允许检测更多阻塞
   * `epoll`：Linux特有，支持高并发

### Linux操作系统中哪个命令可以查看端口被哪个应用占用？
* `lsof`
* `netstat`
