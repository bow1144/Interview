## 进程

### 1. 进程的概念
进程是一个具有独立功能的**程序**在一个**数据集合**上运行的过程，是**系统进行资源分配和调度的一个独立单位**

### 2. 进程控制块PCB
系统通过PCB获取进程的基本情况和运行状态，从而控制和管理进程。**PCB是进程存在的唯一标识**  
PCB包含以下信息：
1. **进程描述信息**：进程标识符，用户标识符
2. **进程控制管理信息**：进程当前状态，进程优先级
3. **进程资源分配清单**：内存地址空间、打开文件列表、所用IO设备信息
4. **CPU相关信息**：进程切换时CPU寄存器的值存在PCB中，以便重新执行

### 3. 并行与并发
1. **并发**是**单个**处理核在短时间执行多个进程。CPU切换进程必须在PCB中记录当前状态信息，一遍切换回来时继续执行
2. **并行**是**多个**处理核同时执行多个进程

### 4. 进程的状态切换
1. 运行态：进程占用CPU
2. 就绪态：可运行，等待其它运行中的进程
3. 阻塞态：等待IO等事件发生而暂停
4. 创建状态：进程正在被创建
5. 结束状态：进程正在从系统中消失

<img width="576" alt="{98091CE5-D29A-4A6B-B5B3-33F375D4412A}" src="https://github.com/user-attachments/assets/502ad9e1-ba6b-4c05-8ba4-2f70f5d07054">

如果有大量进程阻塞，操作系统将阻塞态进程换出到**硬盘**，需要运行时再换到内存。**挂起状态**描述没有占用物理内存的进程；挂起可以分为阻塞挂起与就绪挂起  
* 阻塞挂起状态：在硬盘等待事件
* 就绪挂起状态：在硬盘等待，只要进入内存就立刻运行

<img width="576" alt="{9548C2CA-FA53-4403-A08B-0DB76335E385}" src="https://github.com/user-attachments/assets/2902b156-ab43-4dc1-b5da-08b4fea686d5">

**进程切换的特点**  
1. 只有就绪态和运行态可以互相转化（操作系统调度进程时），其它都是单向转化
2. 进程用完CPU时间片会从运行态变为就绪态
3. 阻塞态是**缺少资源**的运行态转化来的，但这个资源不包括CPU时间片
4. 外部事件发生后由阻塞态变为运行态或就绪态

### 5. 进程的上下文切换
**一个进程切换到另一个进程运行**称为进程的上下文切换。进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户资源，还包括了内核堆栈，寄存器等内核空间资源  
进程的上下文切换在以下情况发生：  
* 运行态与其它状态之间的转化
* 进程通过`sleep()`等方法自我挂起

### 6. 进程的创建
一个进程可以创建另一个进程，被称为**父进程与子进程**。OS创建进程的过程如下：  
1. 分配PCB
2. 分配资源
3. 初始化PCB
4. 将其设置为就绪态

### 7. 进程的终止
1. 操作系统根据标识符找到需要终止的进程的PCB
2. 掐断执行，让出处理器
3. 如果还有子进程，将其交给一号进程接管

### 8. 进程的阻塞
1. 操作系统找到对应的PCB
2. 从运行态拉出，转化为阻塞态，停止运行
3. 将PCB插入等待队列中，处理机让给其它资源

### 9. 进程的唤醒
1. 在阻塞队列中找到PCB
2. 从阻塞队列移出，置为就绪态
3. 将PCB插入到就绪队列中，等待调度

## 线程

### 1. 什么是线程
* 线程是操作系统能执行的最小单位，也是系统独立和分配的基本单位
* 一个进程包括多个线程，**线程是进程的一条执行流程**
* 进程间共享代码，数据等资源，但也有自己独立的栈，计数器等

### 2. 线程的特点
* **独立性**：线程是程序执行的基本单位，有独立的栈，计数器等。因此可以高效交换数据
* **共享资源**：进程中的线程共享资源，因此交流高效
* **并发性**，各个线程可并发执行

### 3. 进程与线程
> 可以将进程比作公司，线程比作员工。进程拥有自己的资源和管理；线程负责具体的任务，拥有线程的资源

进程是资源分配的单位，线程是CPU调度的单位；线程可以蜕变为进程

事实上在Linux中，创建进程，线程的底层逻辑一样，**复制地址空间是进程，共享对方空间是线程**

**3.1 资源**：
进程是**操作系统中拥有资源的基本单位**，线程只有一点能保证运行的资源，但可以访问隶属进程的资源

**3.2 调度**：
**进程切换的代价远远大于线程**，同一个进程中线程切换不会引起进程切换

**3.3 并发**：
进程，线程都可以并发执行，不同进程中的线程也可以并发执行

**3.4 独立**：
进程之间拥有强独立性，进程不可见另一进程中的线程；同一进程中的线程共享资源

**3.5 系统开销**：
线程的系统开销远远小于进程。在**创建、终止、切换、共享**资源等方面线程的开销远远小于进程。

### 4. 线程的状态：
* 执行状态：线程获得处理机
* 就绪状态：线程已具备执行条件，只需获得CPU
* 阻塞状态：线程因事件而受阻

### 5. 线程的实现

#### 5.1 用户线程 ULT（外包）
**用户级线程由用户在用户空间创建管理的**，操作系统不直到、管理这些线程，而将所有用户级线程视为一个进程。优点是创建，切换线程开销小；缺点是脱离OS管理，无法发挥多核处理器的优势

#### 5.2 内核线程 KLT （正式工，较多）
由OS管理调度，内核中有对应TCB。优点是可以利用OS给管理**并行**执行线程，线程阻塞不会辐射到整个进程；缺点是创建、切换开销较大

#### 5.3 轻量级线程 LWP （派遣）
**内核支持的用户线程**，每个LWP与内核线程一一对应，每个LWP由一个内核线程支持。在一般操作系统中不被重用

### 6. 线程共享资源
线程独立拥有id、栈、优先级等维持生命的资源

### 7. 线程的优缺点
* 优点：提高并发性，开销小，通信方便
* 缺点：不稳定，调试编写困难

### 8. 线程如何减少开销
更快的创建、终止、切换，更高的交流效率

## 进程调度算法

![调度算法](https://github.com/user-attachments/assets/94a64cdb-03e3-4d94-803e-902c62a4bcb6)

#### 多级队列调度算法
多级队列调度算法设置**多个就绪队列**，将不同性质的进程分配到不同的队列，实施不同的调度算法

#### 多级反馈队列调度算法

融合了时间片轮转和优先级调度算法

<img width="576" alt="{940250F7-D9D3-4AE5-BF6D-39F294D0592E}" src="https://github.com/user-attachments/assets/980d76b3-f409-4dd8-b7ac-dee705085c3d">

* 优点：兼顾长作业和短作业；动态调整优先级，平衡系统利用率
* 缺点：实现复杂，对参数要求高

## 进程通信
* 每个进程的空间都在**内核空间**中，所以进程通信必须经过内核

### 1. 共享存储
在通信的进程之间有一块可直接访问的**共享空间**，通过对这块空间读写进行信息交换

### 2. 消息队列
若通信的进程间**不存在共享空间**，则必须用OS提供的**消息传递**方法进行通信。进程通过OS提供的**发送信息**和**接收信息**两个原语进行数据交换

* 直接通信方式：发送进程将消息直接挂在接收进程的消息缓存队列中，接收进程从消息缓冲队列中获取消息
* 间接通信方式：发送进程将消息发送给某个中间实体，接收进程从中间实体获取消息。这种中间实体被称为**信箱**
* 消息队列

### 3. 管道

* 管道（*pipe*）是指用于连接读写进程以实现它们之间通信的**共享文件**，又称**pipe文件**
* 向管道提供输入的进程称之为**写进程**，以字符流的形式将数据**写入**管道
* 接收数据的进程是**读**进程，这一接收过程被称为**读数据**

#### （1） 匿名管道与命名管道的区别
* 匿名管道：用完即销毁、只适用于父子进程之间的通信
* 命名管道：提前创建的设备文件、可以在不相干的进程间通信

#### （2） pipe函数
```
#include <unistd.h>
/**
 * 创建⽆名管道. 
 * @param pipefd 为int型数组的⾸地址，其存放了管道的⽂件描述符 
 * pipefd[0]、pipefd[1].
 * @return 创建成功返回0，创建失败返回-1.
*/
 int pipe(int pipefd[2]);
/** 
 * 当⼀个管道建⽴时，它会创建两个⽂件描述符 fd[0] 和 fd[1]。其中 
 * fd[0] 固定⽤于读管道，⽽ fd[1] 固定⽤于写管道。       
 * ⼀般⽂件 I/O的函数都可以⽤来操作管道(lseek() 除外。）
*/
```

#### （3） 命名管道（FIFO）
* FIFO以一种特殊的**文件**形式存在，但FIFO的内容在**内存**中
* 使用FIFO的进程退出后，FIFO不会销毁
* FIFO有名字，不相干的进程可以通过名字打开FIFO通信

### 4. 信号量
* 信号量用于控制多个进程对共享资源的访问，避免多个进程修改一个共享内存造成冲突
* **信号量可以使共享资源在任意时刻都只能被一个进程访问**
* 主要用于实现进程的互斥与同步，而不是缓存通信数据
* 信号量实际上是一个**int计数器**，可以通过两种基本操作来操作信号量

#### 信号量操作
* 信号量计数器给大小是**受控资源数量**，如果只有一个资源则计数器大小为`1`，代表**互斥信号量**
* P操作（wait）：**用于请求资源的访问权限**
  * 检查信号量，信号量大于`0`则表示资源**可用**，将信号量-1，进入**临界区**，访问资源
  * 如果信号量为`0`，表示资源**不可用**，进程进入等待队列
* V操作（signal）：**归还资源，使等待队列中的进程可以访问资源**
  * 检查信号量，如果为`0`则唤醒等待队列中的进程
  * 将信号量+1

```
P(Semaphore s) {
    while(s <= 0) // 进入等待队列
    s -= 1;       // 表示占用资源
}

V(Semaphore s) {
    s += 1;       // 释放资源 
    if(s == 1)    // 唤醒等待队列中的进程
}
```

#### 同步信号量
将信号量初始化为`0`，只有一个进程生产完数据、执行P操作，才能使其它数据执行

### 5. 信号
信号是进程通信间**唯一的异步机制**，可以在一个进程中通知另一个进程发生了什么事从而实现通信

### 6. Socket通信
Socket通信是一种网络编程中常见的通信方式，也可以在同一机器中通信

### 7. 线程通信
* 线程通信的主要作用是线程同步，所以没有数据交换的通信机制。
* 由于同一进程中的线程共享内存，所以通信方便，只需要将数据复制到共享变量中即可
* 需要避免多个线程同时修改同一信息

### 8. 线程属性
1. **线程ID**：系统给线程的唯一标识符，用于区分线程
2. **优先级**：OS调度器决定的线程优先级，决定了线程获取CPU资源的优先
3. **堆栈大小**：线程执行时可用的栈内存大小
4. **状态**：运行，就绪，阻塞等
5. **调度策略**：获取CPU资源所用的调度策略

### 9. 多线程
一个进程中有多个进程，定义的全局变量会被多线程共享
* 好处：
  1. 将应用程序分解为多个线程简化模型
  2. 开销小，容易创建销毁
  3. 可以彼此重叠运行，加快程序执行速度
* 需要考虑：
  1. 先后顺序
  2. 互斥访问

## 互斥与同步

![互斥与同步](https://github.com/user-attachments/assets/95487fd1-f519-408d-9d64-e296a8c7eae2)

### 1. 互斥锁
* 互斥锁实际上是一种**信号量为1**的锁
* 互斥锁保证了获取共享资源的安全问题，保证同一时刻只有一个线程/进程访问
* 互斥锁的操作
  1. 加锁（Lock）：线程访问资源时如果未锁定，将资源加锁并进入临界区；如果锁已经被其它资源占有则进入阻塞队列
  2. 解锁（Unlock）：用完资源后释放锁
* 优点
  * 简单易用
  * 有效避免资源竞争，保证资源的一致性
* 缺点
  * 性能消耗
  * 容易死锁
  * 优先级得不到保证

### 2. 死锁

#### 死锁的必要条件
* **互斥**：每个资源只能被有限个进程用
* **占有和等待**：不放弃，没拿到就一直等
* **不可抢占**：进程不能抢占资源
* **环路等待**：至少一个有向环

#### 死锁的处理方法
* **鸵鸟算法**：假装什么是都没发生
* **死锁的检测与恢复**：DFS检测有向环
* **从死锁中恢复**：强制挂起进程、强制杀死进程、回滚到更早状态

#### 死锁预防
1. 破坏**互斥条件**：允许资源共享
2. 破坏**占有与等待**：一个进程请求资源时，先释放所有资源、再一次性获得需要的全部资源
3. 破坏**不可抢占**：进程按顺序请求资源
4. 破坏**环路等待**
